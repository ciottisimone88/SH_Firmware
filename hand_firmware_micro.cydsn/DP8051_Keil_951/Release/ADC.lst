C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Release\ADC.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.4\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\ADC.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(NDEBUG) WL(2
                    -) PR(.\DP8051_Keil_951\Release/ADC.lst) CD OT(8,SPEED) OJ(.\DP8051_Keil_951\Release\ADC.obj)

line level    source

*** MESSAGE C286 IN LINE 0 OF (null): license limits optimization to level 5
   1          /*******************************************************************************
   2          * File Name: ADC.c
   3          * Version 3.30
   4          *
   5          * Description:
   6          *  This file provides the source code to the API for the Delta-Sigma ADC
   7          *  Component.
   8          *
   9          * Note:
  10          *
  11          ********************************************************************************
  12          * Copyright 2008-2017, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "ADC.h"
  19          
  20          #if(ADC_DEFAULT_INTERNAL_CLK)
  21              #include "ADC_theACLK.h"
  22          #endif /* ADC_DEFAULT_INTERNAL_CLK */
  23          
  24          #include "ADC_Ext_CP_Clk.h"
  25          
  26          #if(ADC_DEFAULT_INPUT_MODE)
  27              #include "ADC_AMux.h"
  28          #endif /* ADC_DEFAULT_INPUT_MODE */
  29          
  30          
  31          /***************************************
  32          * Global data allocation
  33          ***************************************/
  34          
  35          /* Software flag for checking conversion completed or not */
  36          volatile uint8 ADC_convDone = 0u;
  37          
  38          /* Software flag to stop conversion for single sample conversion mode
  39          *   with resolution above 16 bits 
  40          */
  41          volatile uint8 ADC_stopConversion = 0u;
  42          
  43          /* To run the initialization block only at the start up */
  44          uint8 ADC_initVar = 0u;
  45          
  46          /* To check whether ADC started or not before switching the configuration */
  47          volatile uint8 ADC_started = 0u;
  48          
  49          /* Flag to hold ADC config number. By default active config is 1. */
  50          volatile uint8 ADC_Config = 1u;
  51          
  52          volatile int32 ADC_Offset = 0;
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 2   

  53          volatile int32 ADC_CountsPerVolt;
  54          
  55          
  56          /***************************************
  57          * Local data allocation
  58          ***************************************/
  59          
  60          /* The array with precalculated gain compensation coefficients */
  61          static ADC_GCOR_STRUCT ADC_gcor[ADC_DEFAULT_NUM_CONFIGS];
  62          
  63          
  64          
  65          /***************************************
  66          * Forward function references
  67          ***************************************/
  68          static void ADC_InitConfig(uint8 config) ;
  69          static void ADC_GainCompensation(uint8 inputRange, uint16 idealDecGain, uint16 idealOddDecGain, 
  70                                      uint8 resolution, uint8 config) ;
  71          static void ADC_SetDSMRef0Reg(uint8 value) ;
  72          
  73          
  74          /******************************************************************************
  75          * Function Name: ADC_Init
  76          *******************************************************************************
  77          *
  78          * Summary:
  79          *  Initialize component's parameters to the parameters set by user in the
  80          *  customizer of the component placed onto schematic. Usually called in
  81          * ADC_Start().
  82          *
  83          *
  84          * Parameters:
  85          *  None
  86          *
  87          * Return:
  88          *  None
  89          *
  90          *******************************************************************************/
  91          void ADC_Init(void) 
  92          {
  93   1      
  94   1          ADC_Config = 1u;
  95   1          ADC_convDone = 0u;
  96   1      
  97   1          ADC_Ext_CP_Clk_SetMode(CYCLK_DUTY);
  98   1      
  99   1          /* This is only valid if there is an internal clock */
 100   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 101   1              ADC_theACLK_SetMode(CYCLK_DUTY);
 102   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 103   1      
 104   1          #if(ADC_IRQ_REMOVE == 0u)
 105   1              /* Set interrupt priority */
 106   1              CyIntSetPriority(ADC_INTC_NUMBER, ADC_INTC_PRIOR_NUMBER);
 107   1          #endif   /* End ADC_IRQ_REMOVE */
 108   1      
 109   1          /* Init static registers with common configuration */
 110   1          ADC_DSM_DEM0_REG    = ADC_CFG1_DSM_DEM0;
 111   1          ADC_DSM_DEM1_REG    = ADC_CFG1_DSM_DEM1;
 112   1          ADC_DSM_MISC_REG    = ADC_CFG1_DSM_MISC;
 113   1          ADC_DSM_CLK_REG    |= ADC_CFG1_DSM_CLK;
 114   1          ADC_DSM_REF1_REG    = ADC_CFG1_DSM_REF1;
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 3   

 115   1      
 116   1          ADC_DSM_OUT0_REG    = ADC_CFG1_DSM_OUT0;
 117   1          ADC_DSM_OUT1_REG    = ADC_CFG1_DSM_OUT1;
 118   1      
 119   1          ADC_DSM_CR0_REG     = ADC_CFG1_DSM_CR0;
 120   1          ADC_DSM_CR1_REG     = ADC_CFG1_DSM_CR1;
 121   1      #if(ADC_MI_ENABLE != 0u) /* Enable Modulator Input */
                  ADC_DSM_CR3_REG     |= ADC_DSM_MODBIT_EN;
              #else
 124   1          ADC_DSM_CR3_REG     = ADC_CFG1_DSM_CR3;
 125   1      #endif /* ADC_MI_ENABLE != 0u*/    
 126   1          ADC_DSM_CR8_REG     = ADC_CFG1_DSM_CR8;
 127   1          ADC_DSM_CR9_REG     = ADC_CFG1_DSM_CR9;
 128   1          ADC_DSM_CR13_REG    = ADC_CFG1_DSM_CR13;
 129   1      
 130   1          ADC_DEC_SR_REG      = ADC_CFG1_DEC_SR;
 131   1      
 132   1          /* Calculate Gain compensation coefficients for all configurations */
 133   1          ADC_GainCompensation(ADC_CFG1_INPUT_RANGE,
 134   1                                            ADC_CFG1_IDEAL_DEC_GAIN,
 135   1                                            ADC_CFG1_IDEAL_ODDDEC_GAIN,
 136   1                                            ADC_CFG1_RESOLUTION,
 137   1                                            ADC_CFG1);
 138   1          #if(ADC_DEFAULT_NUM_CONFIGS > 1)
                      ADC_GainCompensation(ADC_CFG2_INPUT_RANGE,
                                                        ADC_CFG2_IDEAL_DEC_GAIN,
                                                        ADC_CFG2_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG2_RESOLUTION,
                                                        ADC_CFG2);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 1 */
 145   1          #if(ADC_DEFAULT_NUM_CONFIGS > 2)
                      ADC_GainCompensation(ADC_CFG3_INPUT_RANGE,
                                                        ADC_CFG3_IDEAL_DEC_GAIN,
                                                        ADC_CFG3_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG3_RESOLUTION,
                                                        ADC_CFG3);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 2 */
 152   1          #if(ADC_DEFAULT_NUM_CONFIGS > 3)
                      ADC_GainCompensation(ADC_CFG4_INPUT_RANGE,
                                                        ADC_CFG4_IDEAL_DEC_GAIN,
                                                        ADC_CFG4_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG4_RESOLUTION,
                                                        ADC_CFG4);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 3 */
 159   1      
 160   1          /* Set GCOR register for config1 */
 161   1          ADC_DEC_GVAL_REG = ADC_gcor[ADC_Config - 1u].gval;
 162   1          CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, ADC_gcor[ADC_Config - 1u].gcor);
 163   1      
 164   1          /* Initialize the registers with default customizer settings for config1 */
 165   1          ADC_InitConfig(ADC_Config);
 166   1      }
 167          
 168          
 169          /******************************************************************************
 170          * Function Name: ADC_Enable
 171          *******************************************************************************
 172          *
 173          * Summary:
 174          *  Enables the ADC DelSig block operation.
 175          *
 176          * Parameters:
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 4   

 177          *  None
 178          *
 179          * Return:
 180          *  None
 181          *
 182          * Side Effects: 
 183          *  Enables internal interrupt.
 184          *
 185          *******************************************************************************/
 186          void ADC_Enable(void) 
 187          {
 188   1              uint8 config;
 189   1          uint8 enableInterrupts;
 190   1          enableInterrupts = CyEnterCriticalSection();
 191   1      
 192   1          /* Read volatile variable to the local variable */
 193   1          config = ADC_Config;
 194   1          
 195   1          /* Enable active mode power for ADC */
 196   1          ADC_PWRMGR_DEC_REG |= ADC_ACT_PWR_DEC_EN;
 197   1          ADC_PWRMGR_DSM_REG |= ADC_ACT_PWR_DSM_EN;
 198   1      
 199   1           /* Enable alternative active mode power for ADC */
 200   1          ADC_STBY_PWRMGR_DEC_REG |= ADC_STBY_PWR_DEC_EN;
 201   1          ADC_STBY_PWRMGR_DSM_REG |= ADC_STBY_PWR_DSM_EN;
 202   1      
 203   1          /* Disable PRES, Enable power to VCMBUF0, REFBUF0 and REFBUF1, enable PRES */
 204   1          ADC_RESET_CR4_REG |= ADC_IGNORE_PRESA1;
 205   1          ADC_RESET_CR5_REG |= ADC_IGNORE_PRESA2;
 206   1      
 207   1          ADC_DSM_CR17_REG |= (ADC_DSM_EN_BUF_VREF | ADC_DSM_EN_BUF_VCM);
 208   1      
 209   1          /* Code to disable the REFBUF0 if reference chosen is External ref */
 210   1          #if (((ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P03) || \
 211   1                (ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P32)) || \
 212   1               ((ADC_DEFAULT_NUM_CONFIGS > 1) && \
 213   1                ((ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P03) ||  \
 214   1                 (ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P32))) || \
 215   1               ((ADC_DEFAULT_NUM_CONFIGS > 2) && \
 216   1                ((ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P03) ||  \
 217   1                 (ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P32))) || \
 218   1               ((ADC_DEFAULT_NUM_CONFIGS > 3) && \
 219   1                ((ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P03) || \
 220   1                 (ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P32))))
                      if (((config == 1u) &&
                          ((ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 2u) &&
                          ((ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 3u) &&
                          ((ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 4u) &&
                          ((ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P32))))
                      {
                          /* Disable the REFBUF0 */
                          ADC_DSM_CR17_REG &= (uint8)~ADC_DSM_EN_BUF_VREF;
                      }
                  #endif /* External ref */
 238   1      
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 5   

 239   1          #if (((ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) || \
 240   1               ((ADC_DEFAULT_NUM_CONFIGS > 1) && \
 241   1                (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)) || \
 242   1               ((ADC_DEFAULT_NUM_CONFIGS > 2) && \
 243   1                (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)) || \
 244   1               ((ADC_DEFAULT_NUM_CONFIGS > 3) && \
 245   1                (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF))))
                      if(((config == 1u) &&
                          (ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                          ((ADC_CFG1_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG1_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 2u) &&
                            (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG2_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG2_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 3u) &&
                            (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG3_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG3_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 4u) &&
                            (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG4_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG4_REFERENCE != ADC_EXT_REF_ON_P32))))
                      {
                          /* Enable the REFBUF1 */
                          ADC_DSM_REF0_REG |= ADC_DSM_EN_BUF_VREF_INN;
                      }
                  #endif /* VSSA_TO_2VREF */
 267   1          if(config != 0u)
 268   1          {
 269   2              /* Suppress compiler warning */
 270   2          }
 271   1      
 272   1          /* Wait for 3 microseconds */
 273   1          CyDelayUs(ADC_PRES_DELAY_TIME);
 274   1      
 275   1          /* Enable the press circuit */
 276   1          ADC_RESET_CR4_REG &= (uint8)~ADC_IGNORE_PRESA1;
 277   1          ADC_RESET_CR5_REG &= (uint8)~ADC_IGNORE_PRESA2;
 278   1      
 279   1          /* Enable negative pumps for DSM  */
 280   1          ADC_PUMP_CR1_REG  |= ( ADC_PUMP_CR1_CLKSEL | ADC_PUMP_CR1_FORCE );
 281   1      
 282   1          /* Enable Modulator Chopping if required */
 283   1          ADC_DSM_CR2_REG = ADC_CFG1_DSM_CR2;
 284   1      
 285   1          /* This is only valid if there is an internal clock */
 286   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 287   1              ADC_PWRMGR_CLK_REG |= ADC_ACT_PWR_CLK_EN;
 288   1              ADC_STBY_PWRMGR_CLK_REG |= ADC_STBY_PWR_CLK_EN;
 289   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 290   1      
 291   1          /* Enable the active and alternate active power for charge pump clock */
 292   1          ADC_PWRMGR_CHARGE_PUMP_CLK_REG |= ADC_ACT_PWR_CHARGE_PUMP_CLK_EN;
 293   1          ADC_STBY_PWRMGR_CHARGE_PUMP_CLK_REG |= ADC_STBY_PWR_CHARGE_PUMP_CLK_EN;
 294   1      
 295   1          #if(ADC_IRQ_REMOVE == 0u)
 296   1              /* Clear a pending interrupt */
 297   1              CyIntClearPending(ADC_INTC_NUMBER);
 298   1              /* Enable interrupt */
 299   1              CyIntEnable(ADC_INTC_NUMBER);
 300   1          #endif   /* End ADC_IRQ_REMOVE */
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 6   

 301   1      
 302   1          CyExitCriticalSection(enableInterrupts);
 303   1      
 304   1      }
 305          
 306          
 307          /*******************************************************************************
 308          * Function Name: ADC_Start
 309          ********************************************************************************
 310          *
 311          * Summary:
 312          *  Performs all required initialization for this component and enables
 313          *  the power. It configure all the register the first time it is called.
 314          *  Subsequent calls of the Start function only enable the ADC and turn
 315          *  on the power. If multiple configurations are selected, it will
 316          *  configure the ADC for configuration 1 by default, unless the
 317          *  ADC_SelectConfiguration( ) function has been called to change
 318          *  the default setting.
 319          *
 320          * Parameters:
 321          *  None
 322          *
 323          * Return:
 324          *  None
 325          *
 326          * Global variables:
 327          *  ADC_initVar:  Used to check the initial configuration,
 328          *  modified when this function is called for the first time.
 329          *
 330          * Side Effects: 
 331          *  Enables internal interrupt.
 332          *
 333          *******************************************************************************/
 334          void ADC_Start(void) 
 335          {
 336   1          if(ADC_initVar == 0u)
 337   1          {
 338   2              if(ADC_started == 0u)
 339   2              {
 340   3                  ADC_Init();
 341   3              }
 342   2              ADC_initVar = 1u;
 343   2          }
 344   1      
 345   1          /* Enable the ADC */
 346   1          ADC_Enable();
 347   1      }
 348          
 349          
 350          /*******************************************************************************
 351          * Function Name: ADC_Stop
 352          ********************************************************************************
 353          *
 354          * Summary:
 355          *  This function stops and powers down the ADC component and the internal
 356          *  clock if the external clock is not selected. If an external clock is
 357          *  used, it is up to the designer to power down the external clock it
 358          *  required.
 359          *
 360          * Parameters:
 361          *  None
 362          *
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 7   

 363          * Return:
 364          *  None
 365          *
 366          *******************************************************************************/
 367          void ADC_Stop(void) 
 368          {
 369   1          uint8 enableInterrupts;
 370   1          enableInterrupts = CyEnterCriticalSection();
 371   1      
 372   1          /* Stop conversions */
 373   1          ADC_DEC_CR_REG &= (uint8)~ADC_DEC_START_CONV;
 374   1          ADC_DEC_SR_REG |=  ADC_DEC_INTR_CLEAR;
 375   1      
 376   1          /* Disable PRES, Disable power to VCMBUF0, REFBUF0 and REFBUF1,
 377   1             enable PRES */
 378   1          ADC_RESET_CR4_REG |= ADC_IGNORE_PRESA1;
 379   1          ADC_RESET_CR5_REG |= ADC_IGNORE_PRESA2;
 380   1      
 381   1          ADC_DSM_CR17_REG &= (uint8)~(ADC_DSM_EN_BUF_VREF | ADC_DSM_EN_BUF_VCM);
 382   1          ADC_DSM_REF0_REG &= (uint8)~ADC_DSM_EN_BUF_VREF_INN;
 383   1      
 384   1          /* Wait for 3 microseconds. */
 385   1          CyDelayUs(ADC_PRES_DELAY_TIME);
 386   1      
 387   1          /* Enable the press circuit */
 388   1          ADC_RESET_CR4_REG &= (uint8)~ADC_IGNORE_PRESA1;
 389   1          ADC_RESET_CR5_REG &= (uint8)~ADC_IGNORE_PRESA2;
 390   1      
 391   1          /* Disable power to the ADC */
 392   1          ADC_PWRMGR_DSM_REG &= (uint8)~ADC_ACT_PWR_DSM_EN;
 393   1      
 394   1          /* Disable power to Decimator block */
 395   1          ADC_PWRMGR_DEC_REG &= (uint8)~ADC_ACT_PWR_DEC_EN;
 396   1      
 397   1          /* Disable alternative active power to the ADC */
 398   1          ADC_STBY_PWRMGR_DEC_REG &= (uint8)~ADC_STBY_PWR_DEC_EN;
 399   1          ADC_STBY_PWRMGR_DSM_REG &= (uint8)~ADC_STBY_PWR_DSM_EN;
 400   1      
 401   1         /* Disable negative pumps for DSM  */
 402   1          ADC_PUMP_CR1_REG &= (uint8)~(ADC_PUMP_CR1_CLKSEL | ADC_PUMP_CR1_FORCE );
 403   1      
 404   1          /* This is only valid if there is an internal clock */
 405   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 406   1              ADC_PWRMGR_CLK_REG &= (uint8)~ADC_ACT_PWR_CLK_EN;
 407   1              ADC_STBY_PWRMGR_CLK_REG &= (uint8)~ADC_STBY_PWR_CLK_EN;
 408   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 409   1      
 410   1          /* Disable Modulator Chopping */
 411   1          ADC_DSM_CR2_REG &= (uint8)~ADC_DSM_MOD_CHOP_EN;
 412   1          /* Disable power to charge pump clock */
 413   1          ADC_PWRMGR_CHARGE_PUMP_CLK_REG &= (uint8)~ADC_ACT_PWR_CHARGE_PUMP_CLK_EN;
 414   1          ADC_STBY_PWRMGR_CHARGE_PUMP_CLK_REG &= (uint8)~ADC_STBY_PWR_CHARGE_PUMP_CLK_EN;
 415   1          
 416   1          CyExitCriticalSection(enableInterrupts);
 417   1      }
 418          
 419          
 420          /*******************************************************************************
 421          * Function Name: ADC_SetBufferGain
 422          ********************************************************************************
 423          *
 424          * Summary:
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 8   

 425          *  Sets input buffer gain.
 426          *
 427          * Parameters:
 428          *  gain:  Two bit value to select a gain of 1, 2, 4, or 8.
 429          *
 430          * Return:
 431          *  None
 432          *
 433          *******************************************************************************/
 434          void ADC_SetBufferGain(uint8 gain) 
 435          {
 436   1          uint8 tmpReg;
 437   1          tmpReg = ADC_DSM_BUF1_REG & (uint8)~ADC_DSM_GAIN_MASK;
 438   1          tmpReg |= (uint8)(gain << ADC_DSM_GAIN_SHIFT) & ADC_DSM_GAIN_MASK;
 439   1          ADC_DSM_BUF1_REG = tmpReg;
 440   1      }
 441          
 442          
 443          /*******************************************************************************
 444          * Function Name: ADC_SetCoherency
 445          ********************************************************************************
 446          *
 447          * Summary:
 448          *  This function allows the user to change which of the ADC's 3 word
 449          *  result will trigger a coherency unlock. The ADC's result will not be
 450          *  updated until the set byte is read either by the ADC or DMA. 
 451          *  By default the LSB is the coherency byte for right alignment data format. 
 452          *  The middle or high byte is set automatically depend on left alignment 
 453          *  configuration for DMA data transfer.
 454          *  If DMA or if a custom API requires different byte to be read the last,
 455          *  this API should be used to set the last byte of the ADC result that is read. 
 456          *  If a multibyte read is performed either by DMA or the ARM processor, the
 457          *  coherency can be set to any byte in the last word read.
 458          *
 459          * Parameters:
 460          *  coherency:  Two bit value to set the coherency bit.
 461          *           00-Coherency checking off
 462          *           01-low byte is key byte
 463          *           02-middle byte is the key byte
 464          *           03-high byte is the key byte
 465          *
 466          * Return:
 467          *  None
 468          *
 469          *******************************************************************************/
 470          void ADC_SetCoherency(uint8 coherency) 
 471          {
 472   1          uint8 tmpReg;
 473   1      
 474   1          tmpReg = ADC_DEC_COHER_REG & (uint8)~ADC_DEC_SAMP_KEY_MASK;
 475   1          tmpReg |= coherency & ADC_DEC_SAMP_KEY_MASK;
 476   1          ADC_DEC_COHER_REG = tmpReg;
 477   1      }
 478          
 479          
 480          /*******************************************************************************
 481          * Function Name: ADC_SetGCOR
 482          ********************************************************************************
 483          *
 484          * Summary:
 485          *  Calculates a new GCOR value and writes it into the GCOR register. 
 486          *  The GCOR value is a 16-bit value that represents a gain of 0 to 2. 
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 9   

 487          *  The ADC result is multiplied by this value before it is placed in the ADC 
 488          *  output registers. The numerical format for the GCOR value is:
 489          *  0x0000 -> 0.000
 490          *  0x8000 -> 1.000
 491          *  0xFFFF -> 1.99997
 492          *  When executing the function, the old GCOR value is multiplied by
 493          *  gainAdjust and reloaded into the GCOR register.
 494          *
 495          * Parameters:
 496          *  gainAdjust:  floating point value to set GCOR registers.
 497          *
 498          * Return:
 499          *  uint8: 0 - if GCOR value is within the expected range.
 500          *         1 - the correction value is outside GCOR value range of
 501          *             0.00 to 1.9999.
 502          *
 503          * Side Effects:  The GVAL register is set to the amount of valid bits in the
 504          *                GCOR  register minus one. If GVAL is 15 (0x0F), all 16 bits
 505          *                of the GCOR registers will be valid. If for example GVAL is
 506          *                11 (0x0B) only 12 bits will be valid. The least 4 bits will
 507          *                be lost when the GCOR value is shifted 4 places to the right.
 508          *
 509          ******************************************************************************/
 510          uint8 ADC_SetGCOR(float32 gainAdjust) 
 511          {
 512   1          uint16 tmpReg;
 513   1          uint8 status;
 514   1          float32 tmpValue;
 515   1      
 516   1          tmpReg = ADC_gcor[ADC_Config - 1u].gcor;
 517   1          tmpValue = ((float32)tmpReg / (float32)ADC_IDEAL_GAIN_CONST);
 518   1          tmpValue = tmpValue * gainAdjust;
 519   1      
 520   1          if (tmpValue > 1.9999)
 521   1          {
 522   2              status = 1u;
 523   2          }
 524   1          else
 525   1          {
 526   2              tmpValue *= (float32)ADC_IDEAL_GAIN_CONST;
 527   2                      tmpReg = (uint16)tmpValue;
 528   2              CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, tmpReg);
 529   2              /* Update gain array to be used by SelectConfiguration() API */
 530   2             ADC_gcor[ADC_Config - 1u].gcor = tmpReg;
 531   2      
 532   2              status = 0u;
 533   2      
 534   2          }
 535   1          return(status);
 536   1      }
 537          
 538          
 539          /******************************************************************************
 540          * Function Name: ADC_ReadGCOR
 541          *******************************************************************************
 542          *
 543          * Summary:
 544          *  This API returns the current GCOR register value, normalized based on the
 545          *  GVAL register settings.
 546          *  For example, if the GCOR value is 0x0812 and the GVAL register is set to 
 547          *  11 (0x0B) then the returned value will be shifted by for bits to the left.
 548          *  (Actual GCOR value = 0x0812, returned value = 0x8120)
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 10  

 549          *
 550          * Parameters:
 551          *  None
 552          *
 553          * Return:
 554          *  uint16:  Normalized GCOR value.
 555          *
 556          *******************************************************************************/
 557          uint16 ADC_ReadGCOR(void) 
 558          {
 559   1          uint8 gValue;
 560   1          uint16 gcorValue;
 561   1      
 562   1          gValue = ADC_DEC_GVAL_REG;
 563   1          gcorValue = CY_GET_REG16(ADC_DEC_GCOR_16B_PTR);
 564   1      
 565   1          if (gValue < ADC_MAX_GVAL)
 566   1          {
 567   2              gcorValue <<= ADC_MAX_GVAL - gValue;
 568   2          }
 569   1      
 570   1          return gcorValue;
 571   1      }
 572          
 573          
 574          /*******************************************************************************
 575          * Function Name: ADC_StartConvert
 576          ********************************************************************************
 577          *
 578          * Summary:
 579          *  Forces the ADC to initiate a conversion. If in the "Single Sample"
 580          *  mode, one conversion will be performed then the ADC will halt. If in
 581          *  one of the other three conversion modes, the ADC will run
 582          *  continuously until the ADC_Stop() or ADC_StopConvert() is called.
 583          *
 584          * Parameters:
 585          *  None
 586          *
 587          * Return:
 588          *  None
 589          *
 590          *******************************************************************************/
 591          void ADC_StartConvert(void) 
 592          {
 593   1          /* Start the conversion */
 594   1          ADC_DEC_CR_REG |= ADC_DEC_START_CONV;
 595   1      }
 596          
 597          
 598          /*******************************************************************************
 599          * Function Name: ADC_StopConvert
 600          ********************************************************************************
 601          *
 602          * Summary:
 603          *  Forces the ADC to stop all conversions. If the ADC is in the middle of a
 604          *  conversion, the ADC will be reset and not provide a result for that partial
 605          *  conversion.
 606          *
 607          * Parameters:
 608          *  None
 609          *
 610          * Return:
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 11  

 611          *  None
 612          *
 613          *******************************************************************************/
 614          void ADC_StopConvert(void) 
 615          {
 616   1          /* Stop all conversions */
 617   1          ADC_DEC_CR_REG &= (uint8)~ADC_DEC_START_CONV;
 618   1      }
 619          
 620          
 621          /*******************************************************************************
 622          * Function Name: ADC_IsEndConversion
 623          ********************************************************************************
 624          *
 625          * Summary:
 626          *  Checks the status that the most recently started conversion has completed.
 627          *  The status is cleared by any of ADC_GetResult8(), ADC_GetResult16() or 
 628          *  ADC_GetResult32() API.
 629          *  This function provides the programmer with two options. In one mode this 
 630          *  function immediately returns with the conversion status. In the other mode,
 631          *  the function does not return (blocking) until the conversion has completed.
 632          *
 633          * Parameters:
 634          *  retMode: Check conversion return mode. See the following table for options.
 635          *   ADC_RETURN_STATUS -   Immediately returns conversion result
 636          *                                      status.
 637          *   ADC_WAIT_FOR_RESULT - Does not return until ADC conversion
 638          *                                      is complete.
 639          *
 640          * Return:
 641          *  If a nonzero value is returned, the last conversion has completed.
 642          *  If the returned value is zero, the ADC is still calculating the last result.
 643          *
 644          * Global variables:
 645          *  ADC_convDone:  Used to check whether conversion is complete
 646          *  or not for single sample mode with resolution is above 16
 647          *
 648          *******************************************************************************/
 649          uint8 ADC_IsEndConversion(uint8 retMode) 
 650          {
 651   1          uint8 status;
 652   1      
 653   1          do
 654   1          {
 655   2              /* Check for stop convert if conversion mode is Single Sample with
 656   2              *   resolution above 16 bit
 657   2              */
 658   2              if(ADC_stopConversion != 0u)
 659   2              {
 660   3                  status = ADC_convDone;
 661   3              }
 662   2              else
 663   2              {
 664   3                  status = ADC_DEC_SR_REG & ADC_DEC_CONV_DONE;
 665   3              }
 666   2          }while((status != ADC_DEC_CONV_DONE) && (retMode == ADC_WAIT_FOR_RESULT));
 667   1      
 668   1          return(status);
 669   1      }
 670          
 671          
 672          /*******************************************************************************
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 12  

 673          * Function Name: ADC_GetResult8
 674          ********************************************************************************
 675          *
 676          * Summary:
 677          *  This function returns the result of an 8-bit conversion. If the
 678          *  resolution is set greater than 8-bits, the LSB of the result will be
 679          *  returned. When the ADC is configured for 8-bit single ended mode,
 680          *  the ADC_GetResult16() function should be used instead. This
 681          *  function returns only signed 8-bit values. The maximum positive
 682          *  signed 8-bit value is 127, but in singled ended 8-bit mode, the
 683          *  maximum positive value is 255.
 684          *
 685          * Parameters:
 686          *  None
 687          *
 688          * Return:
 689          *  int8: The LSB of the last ADC conversion.
 690          *
 691          * Global variables:
 692          *  ADC_convDone:  Cleared in single sample mode with resolution
 693          *                              above 16 bits
 694          *
 695          *******************************************************************************/
 696          int8 ADC_GetResult8( void ) 
 697          {
 698   1          int8 result;
 699   1          uint8 coherency;
 700   1      
 701   1          /* Read active coherency configuration */
 702   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 703   1      
 704   1          result = (int8)ADC_DEC_SAMP_REG;
 705   1      
 706   1          if(coherency == ADC_DEC_SAMP_KEY_MID)
 707   1          {   /* Dummy read of the middle byte to unlock the coherency */
 708   2              (void)ADC_DEC_SAMPM_REG;
 709   2          }
 710   1          else  if(coherency == ADC_DEC_SAMP_KEY_HIGH)
 711   1          {   /* Dummy read of the MSB byte to unlock the coherency */
 712   2              (void)ADC_DEC_SAMPH_REG;
 713   2          }
 714   1          else /*No action required for other coherency */
 715   1          {
 716   2          }
 717   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 718   1          if(ADC_stopConversion != 0u)
 719   1          {
 720   2              ADC_convDone = 0u;
 721   2          }
 722   1          return (result);
 723   1      }
 724          
 725          
 726          /*******************************************************************************
 727          * Function Name: ADC_GetResult16
 728          ********************************************************************************
 729          *
 730          * Summary:
 731          *  Returns a 16-bit result for a conversion with a result that has a
 732          *  resolution of 8 to 16 bits. If the resolution is set greater than 16-bits,
 733          *  it will return the 16 least significant bits of the result. When the ADC
 734          *  is configured for 16-bit single ended mode, the ADC_GetResult32()
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 13  

 735          *  function should be used instead. This function returns only signed
 736          *  16-bit result, which allows a maximum positive value of 32767, not 65535.
 737          *  This function supports different coherency settings.
 738          *
 739          * Parameters:
 740          *   void
 741          *
 742          * Return:
 743          *  int16:  ADC result.
 744          *
 745          * Global variables:
 746          *  ADC_convDone:  Cleared in single sample mode with resolution
 747          *                              above 16 bits
 748          *
 749          *******************************************************************************/
 750          int16 ADC_GetResult16(void) 
 751          {
 752   1          uint16 result;
 753   1          uint8 coherency;
 754   1      
 755   1          /* Read active coherency configuration */
 756   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 757   1      
 758   1          if(coherency <= ADC_DEC_SAMP_KEY_LOW)
 759   1          {   /*  Use default method to read result registers i.e. LSB byte read at the end*/
 760   2              #if (CY_PSOC3)
 761   2                  result = ADC_DEC_SAMPM_REG;
 762   2                  result = (result << 8u) | ADC_DEC_SAMP_REG;
 763   2              #else
                          result = (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
                      #endif /* CY_PSOC3 */
 766   2          }
 767   1          else /* MID or HIGH */
 768   1          {   /* Read middle byte at the end */
 769   2              #if (CY_PSOC3)
 770   2                  result = (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
 771   2              #else
                          result = ADC_DEC_SAMP_REG;
                          result |=  (uint16)((uint16)ADC_DEC_SAMPM_REG << 8u);
                      #endif /* CY_PSOC3 */
 775   2              if(coherency == ADC_DEC_SAMP_KEY_HIGH)
 776   2              {   /* Dummy read of the MSB byte to unlock the coherency */
 777   3                  (void)ADC_DEC_SAMPH_REG;
 778   3              }
 779   2          }
 780   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 781   1          if(ADC_stopConversion != 0u)
 782   1          {
 783   2              ADC_convDone = 0u;
 784   2          }
 785   1      
 786   1          return ((int16)result);
 787   1      }
 788          
 789          
 790          /*******************************************************************************
 791          * Function Name: ADC_GetResult32
 792          ********************************************************************************
 793          *
 794          * Summary:
 795          *  Returns a 32-bit result for a conversion with a result that has a
 796          *  resolution of 8 to 20 bits.
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 14  

 797          *  This function supports different coherency settings.
 798          *
 799          * Parameters:
 800          *  None
 801          *
 802          * Return:
 803          *  int32: Result of the last ADC conversion.
 804          *
 805          * Global variables:
 806          *  ADC_convDone:  Cleared in single sample mode with resolution
 807          *                              above 16 bits
 808          *
 809          *******************************************************************************/
 810          int32 ADC_GetResult32(void) 
 811          {
 812   1          uint32 result;
 813   1          uint8 coherency;
 814   1          #if (CY_PSOC3)
 815   1                  uint16 tmp;
 816   1          #endif /* CY_PSOC3 */
 817   1      
 818   1          /* Read active coherency configuration */
 819   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 820   1      
 821   1          if(coherency <= ADC_DEC_SAMP_KEY_LOW)
 822   1          {   /*  Use default method to read result registers i.e. LSB byte read at the end*/
 823   2              #if (CY_PSOC3)
 824   2                  result = ADC_DEC_SAMPH_REG;
 825   2                  if((result & 0x80u) != 0u)
 826   2                  {   /* Sign extend */
 827   3                      result |= 0xFF00u;
 828   3                  }
 829   2                  result = (result << 8u) | ADC_DEC_SAMPM_REG;
 830   2                  result = (result << 8u) | ADC_DEC_SAMP_REG;
 831   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR);
                          result = (result << 16u) | (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
                      #endif /* CY_PSOC3 */
 835   2          }
 836   1          else if(coherency == ADC_DEC_SAMP_KEY_MID)
 837   1          {   /* Read middle byte at the end */
 838   2              #if (CY_PSOC3)
 839   2                  result = ADC_DEC_SAMPH_REG;
 840   2                  if((result & 0x80u) != 0u)
 841   2                  {   /* Sign extend */
 842   3                      result |= 0xFF00u;
 843   3                  }
 844   2                  result = (result << 16u) | (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
 845   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR);
                          result = (result << 16u) | ADC_DEC_SAMP_REG;
                          result |=  (uint32)((uint32)ADC_DEC_SAMPM_REG << 8u);
                      #endif /* CY_PSOC3 */
 850   2          }
 851   1          else /*ADC_DEC_SAMP_KEY_HIGH */
 852   1          {
 853   2              /* Read MSB byte at the end */
 854   2              #if (CY_PSOC3)
 855   2                  result = CY_GET_REG16(ADC_DEC_SAMP_16B_PTR);
 856   2                              tmp = ADC_DEC_SAMPH_REG;
 857   2                  if((tmp & 0x80u) != 0u)
 858   2                  {   /* Sign extend */
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 15  

 859   3                      tmp |= 0xFF00u;
 860   3                  }
 861   2                  result |= (uint32)tmp << 16u;
 862   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMP_16B_PTR);
                          result |= (uint32)((uint32)CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR) << 16u);
                      #endif /* CY_PSOC3 */
 866   2          }
 867   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 868   1          if(ADC_stopConversion != 0u)
 869   1          {
 870   2              ADC_convDone = 0u;
 871   2          }
 872   1      
 873   1          return ((int32)result);
 874   1      }
 875          
 876          
 877          /*******************************************************************************
 878          * Function Name: ADC_SetOffset
 879          ********************************************************************************
 880          *
 881          * Summary:
 882          *  Sets the ADC offset which is used by the functions ADC_CountsTo_uVolts, 
 883          *  ADC_CountsTo_mVolts, and ADC_CountsTo_Volts to subtract the offset from the 
 884          *  given reading before calculating the voltage conversion.
 885          *
 886          * Parameters:
 887          *  int32:  This value is a measured value when the inputs are shorted or 
 888          *          connected to the same input voltage.
 889          *
 890          * Return:
 891          *  None
 892          *
 893          * Global variables:
 894          *  ADC_Offset:  Modified to set the user provided offset. This
 895          *  variable is used for offset calibration purpose.
 896          *
 897          * Side Effects:
 898          *  Affects the ADC_CountsTo_Volts,
 899          *  ADC_CountsTo_mVolts, ADC_CountsTo_uVolts functions
 900          *  by subtracting the given offset.
 901          *
 902          *******************************************************************************/
 903          void ADC_SetOffset(int32 offset) 
 904          {
 905   1      
 906   1          ADC_Offset = offset;
 907   1      }
 908          
 909          
 910          /*******************************************************************************
 911          * Function Name: ADC_SetGain
 912          ********************************************************************************
 913          *
 914          * Summary:
 915          *  Sets the ADC gain in counts per volt for the voltage conversion
 916          *  functions below. This value is set by default by the reference and
 917          *  input range settings. It should only be used to further calibrate the
 918          *  ADC with a known input or if an external reference is used. This
 919          *  function may also be used to calibrate an entire signal chain, not
 920          *  just the ADC.
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 16  

 921          *
 922          * Parameters:
 923          *  int32: ADC gain in counts per volt.
 924          *
 925          * Return:
 926          *  None
 927          *
 928          * Global variables:
 929          *  ADC_CountsPerVolt:  modified to set the ADC gain in counts
 930          *   per volt.
 931          *
 932          * Side Effects:
 933          *  Affects the ADC_CountsTo_Volts,
 934          *  ADC_CountsTo_mVolts, ADC_CountsTo_uVolts functions
 935          *  supplying the correct conversion between ADC counts and voltage.
 936          *
 937          *******************************************************************************/
 938          void ADC_SetGain(int32 adcGain) 
 939          {
 940   1          ADC_CountsPerVolt = adcGain;
 941   1      }
 942          
 943          
 944          /*******************************************************************************
 945          * Function Name: ADC_CountsTo_mVolts
 946          ********************************************************************************
 947          *
 948          * Summary:
 949          *  Converts the ADC counts output to mVolts as a 16-bit integer. For
 950          *  example, if the ADC measured 0.534 volts, the return value would
 951          *  be 534 mVolts.
 952          *
 953          * Parameters:
 954          *  int32: adcCounts Result from the ADC conversion.
 955          *
 956          * Return:
 957          *  int16:  Result in mVolts
 958          *
 959          * Global variables:
 960          *  ADC_CountsPerVolt:  used to convert ADC counts to mVolts.
 961          *  ADC_Offset:  Used as the offset while converting ADC counts
 962          *   to mVolts.
 963          *
 964          *******************************************************************************/
 965          int16 ADC_CountsTo_mVolts(int32 adcCounts) 
 966          {
 967   1      
 968   1          int16 mVolts;
 969   1      
 970   1          /* Convert adcCounts to the right align if left option selected */
 971   1          #if(ADC_CFG1_DEC_DIV != 0)
                      if(ADC_Config == ADC_CFG1)
                      {
                          adcCounts /= ADC_CFG1_DEC_DIV;
                      }
                  #endif /* ADC_CFG1_DEC_DIV */
 977   1          #if((ADC_CFG2_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 1))
                      if(ADC_Config == ADC_CFG2)
                      {
                          adcCounts /= ADC_CFG2_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 17  

 983   1          #if((ADC_CFG3_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 2))
                      if(ADC_Config == ADC_CFG3)
                      {
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
 989   1          #if((ADC_CFG4_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 3))
                      if(ADC_Config == ADC_CFG4)
                      {
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
 995   1      
 996   1          /* Subtract ADC offset */
 997   1          adcCounts -= ADC_Offset;
 998   1      
 999   1          mVolts = (int16)(( adcCounts * ADC_1MV_COUNTS ) / ADC_CountsPerVolt) ;
1000   1      
1001   1          return(mVolts);
1002   1      }
1003          
1004          
1005          /*******************************************************************************
1006          * Function Name: ADC_CountsTo_Volts
1007          ********************************************************************************
1008          *
1009          * Summary:
1010          *  Converts the ADC output to Volts as a floating point number. For
1011          *  example, if the ADC measure a voltage of 1.2345 Volts, the
1012          *  returned result would be +1.2345 Volts.
1013          *
1014          * Parameters:
1015          *  int32 adcCounts:  Result from the ADC conversion.
1016          *
1017          * Return:
1018          *  float32: Result in Volts
1019          *
1020          * Global variables:
1021          *  ADC_CountsPerVolt:  used to convert to Volts.
1022          *  ADC_Offset:  Used as the offset while converting ADC counts
1023          *   to Volts.
1024          *
1025          *******************************************************************************/
1026          float32 ADC_CountsTo_Volts(int32 adcCounts) 
1027          {
1028   1      
1029   1          float32 Volts;
1030   1      
1031   1          /* Convert adcCounts to the right align if left option selected */
1032   1          #if(ADC_CFG1_DEC_DIV != 0)
                      if(ADC_Config == ADC_CFG1)
                      {
                          adcCounts /= ADC_CFG1_DEC_DIV;
                      }
                  #endif /* ADC_CFG1_DEC_DIV */
1038   1          #if((ADC_CFG2_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 1))
                      if(ADC_Config == ADC_CFG2)
                      {
                          adcCounts /= ADC_CFG2_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
1044   1          #if((ADC_CFG3_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 2))
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 18  

                      if(ADC_Config == ADC_CFG3)
                      {
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
1050   1          #if((ADC_CFG4_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 3))
                      if(ADC_Config == ADC_CFG4)
                      {
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
1056   1      
1057   1          /* Subtract ADC offset */
1058   1          adcCounts -= ADC_Offset;
1059   1      
1060   1          Volts = (float32)adcCounts / (float32)ADC_CountsPerVolt;
1061   1      
1062   1          return( Volts );
1063   1      }
1064          
1065          
1066          /*******************************************************************************
1067          * Function Name: ADC_CountsTo_uVolts
1068          ********************************************************************************
1069          *
1070          * Summary:
1071          *  Converts the ADC output to uVolts as a 32-bit integer. For example,
1072          *  if the ADC measured -0.02345 Volts, the return value would be -23450 uVolts.
1073          *
1074          * Parameters:
1075          *  int32 adcCounts: Result from the ADC conversion.
1076          *
1077          * Return:
1078          *  int32:  Result in uVolts
1079          *
1080          * Global variables:
1081          *  ADC_CountsPerVolt:  used to convert ADC counts to mVolts.
1082          *  ADC_Offset:  Used as the offset while converting ADC counts
1083          *   to mVolts.
1084          *
1085          * Theory:
1086          *  Care must be taken to not exceed the maximum value for a 31 bit signed
1087          *  number in the conversion to uVolts and at the same time not lose resolution.
1088          *
1089          *  uVolts = ((A * adcCounts) / ((int32)ADC_CountsPerVolt / B));
1090          *
1091          *******************************************************************************/
1092          int32 ADC_CountsTo_uVolts(int32 adcCounts) 
1093          {
1094   1      
1095   1          int32 uVolts;
1096   1          int32 coefA;
1097   1          int32 coefB;
1098   1          uint8 resolution;
1099   1      
1100   1          /* Set the resolution based on the configuration */
1101   1          /* Convert adcCounts to the right align if left option selected */
1102   1          if (ADC_Config == ADC_CFG1)
1103   1          {
1104   2              resolution = ADC_CFG1_RESOLUTION;
1105   2              #if(ADC_CFG1_DEC_DIV != 0)
                          adcCounts /= ADC_CFG1_DEC_DIV;
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 19  

                      #endif /* ADC_CFG1_DEC_DIV */
1108   2          }
1109   1          else if (ADC_Config == ADC_CFG2)
1110   1          {
1111   2              resolution = ADC_CFG2_RESOLUTION;
1112   2              #if(ADC_CFG2_DEC_DIV != 0)
                          adcCounts /= ADC_CFG2_DEC_DIV;
                      #endif /* ADC_CFG2_DEC_DIV */
1115   2          }
1116   1          else if (ADC_Config == ADC_CFG3)
1117   1          {
1118   2              resolution = ADC_CFG3_RESOLUTION;
1119   2              #if(ADC_CFG3_DEC_DIV != 0)
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      #endif /* ADC_CFG3_DEC_DIV */
1122   2          }
1123   1          else
1124   1          {
1125   2              resolution = ADC_CFG4_RESOLUTION;
1126   2              #if(ADC_CFG4_DEC_DIV != 0)
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      #endif /* ADC_CFG4_DEC_DIV */
1129   2          }
1130   1      
1131   1          switch (resolution)
1132   1          {
1133   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_12) || \
1134   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_12) || \
1135   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_12) || \
1136   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_12) )
1137   2                  case (uint8)ADC__BITS_12:
1138   2                      coefA = ADC_1UV_COUNTS / ADC_DIVISOR_2;
1139   2                      coefB = ADC_DIVISOR_2;
1140   2                      break;
1141   2              #endif /* ADC__BITS_12 */    
1142   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_13) || \
1143   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_13) || \
1144   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_13) || \
1145   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_13) )
                          case (uint8)ADC__BITS_13:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_4;
                              coefB = ADC_DIVISOR_4;
                              break;
                      #endif /* ADC__BITS_13 */    
1151   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_14) || \
1152   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_14) || \
1153   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_14) || \
1154   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_14) )
                          case (uint8)ADC__BITS_14:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_8;
                              coefB = ADC_DIVISOR_8;
                              break;
                      #endif /* ADC__BITS_14 */    
1160   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_15) || \
1161   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_15) || \
1162   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_15) || \
1163   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_15) )
                          case (uint8)ADC__BITS_15:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_16;
                              coefB = ADC_DIVISOR_16;
                              break;
                      #endif /* ADC__BITS_15 */    
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 20  

1169   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_16) || \
1170   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_16) || \
1171   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_16) || \
1172   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_16) )
1173   2                  case (uint8)ADC__BITS_16:
1174   2                      coefA = ADC_1UV_COUNTS / ADC_DIVISOR_32;
1175   2                      coefB = ADC_DIVISOR_32;
1176   2                      break;
1177   2              #endif /* ADC__BITS_16 */    
1178   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_17) || \
1179   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_17) || \
1180   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_17) || \
1181   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_17) )
                          case (uint8)ADC__BITS_17:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_64;
                              coefB = ADC_DIVISOR_64;
                              break;
                      #endif /* ADC__BITS_17 */    
1187   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_18) || \
1188   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_18) || \
1189   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_18) || \
1190   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_18) )
                          case (uint8)ADC__BITS_18:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_125;
                              coefB = ADC_DIVISOR_125;
                              break;
                      #endif /* ADC__BITS_18 */    
1196   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_19) || \
1197   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_19) || \
1198   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_19) || \
1199   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_19) )
                          case (uint8)ADC__BITS_19:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_250;
                              coefB = ADC_DIVISOR_250;
                              break;
                      #endif /* ADC__BITS_19 */    
1205   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_20) || \
1206   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_20) || \
1207   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_20) || \
1208   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_20) )
                          case (uint8)ADC__BITS_20:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_500;
                              coefB = ADC_DIVISOR_500;
                              break;
                      #endif /* ADC__BITS_20 */    
1214   2              default:    /* resolution < 12 */
1215   2                  /* 11 bits ADC + 2^20(1048576) = 31 bits */
1216   2                  coefA = ADC_1UV_COUNTS;
1217   2                  coefB = ADC_DIVISOR_1;
1218   2                  break;
1219   2          }
1220   1          coefB = ADC_CountsPerVolt / coefB;
1221   1          uVolts = ((coefA * adcCounts) / coefB) - ((coefA * ADC_Offset) / coefB);
1222   1      
1223   1          return( uVolts );
1224   1      }
1225          
1226          
1227          /*******************************************************************************
1228          * Function Name: ADC_InitConfig(uint8 config)
1229          ********************************************************************************
1230          *
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 21  

1231          * Summary:
1232          *  Initializes all registers based on customizer settings
1233          *
1234          * Parameters:
1235          *   void
1236          *
1237          * Return:
1238          *  None
1239          *
1240          * Global variables:
1241          *  ADC_CountsPerVolt:  Used to set the default counts per volt.
1242          *
1243          * Side Effects: Rewrites the coherency set by ADC_SetCoherency()
1244          *   API to the default value.
1245          *
1246          *******************************************************************************/
1247          static void ADC_InitConfig(uint8 config) 
1248          {
1249   1          ADC_stopConversion = 0u;
1250   1      
1251   1          if (config == 1u)
1252   1          {
1253   2              /* Default Config */
1254   2              ADC_DEC_CR_REG      = ADC_CFG1_DEC_CR;
1255   2              ADC_DEC_SHIFT1_REG  = ADC_CFG1_DEC_SHIFT1;
1256   2              ADC_DEC_SHIFT2_REG  = ADC_CFG1_DEC_SHIFT2;
1257   2              ADC_DEC_DR2_REG     = ADC_CFG1_DEC_DR2;
1258   2              ADC_DEC_DR2H_REG    = ADC_CFG1_DEC_DR2H;
1259   2              ADC_DEC_DR1_REG     = ADC_CFG1_DEC_DR1;
1260   2              ADC_DEC_OCOR_REG    = ADC_CFG1_DEC_OCOR;
1261   2              ADC_DEC_OCORM_REG   = ADC_CFG1_DEC_OCORM;
1262   2              ADC_DEC_OCORH_REG   = ADC_CFG1_DEC_OCORH;
1263   2              ADC_DEC_COHER_REG   = ADC_CFG1_DEC_COHER;
1264   2      
1265   2              ADC_DSM_CR4_REG     = ADC_CFG1_DSM_CR4;
1266   2              ADC_DSM_CR5_REG     = ADC_CFG1_DSM_CR5;
1267   2              ADC_DSM_CR6_REG     = ADC_CFG1_DSM_CR6;
1268   2              ADC_DSM_CR7_REG     = ADC_CFG1_DSM_CR7;
1269   2              ADC_DSM_CR10_REG    = ADC_CFG1_DSM_CR10;
1270   2              ADC_DSM_CR11_REG    = ADC_CFG1_DSM_CR11;
1271   2              ADC_DSM_CR12_REG    = ADC_CFG1_DSM_CR12;
1272   2              ADC_DSM_CR14_REG    = ADC_CFG1_DSM_CR14;
1273   2              ADC_DSM_CR15_REG    = ADC_CFG1_DSM_CR15;
1274   2              ADC_DSM_CR16_REG    = ADC_CFG1_DSM_CR16;
1275   2              ADC_DSM_CR17_REG    = ADC_CFG1_DSM_CR17;
1276   2              /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
1277   2              ADC_SetDSMRef0Reg(ADC_CFG1_DSM_REF0);
1278   2              ADC_DSM_REF2_REG    = ADC_CFG1_DSM_REF2;
1279   2              ADC_DSM_REF3_REG    = ADC_CFG1_DSM_REF3;
1280   2      
1281   2              ADC_DSM_BUF0_REG    = ADC_CFG1_DSM_BUF0;
1282   2              ADC_DSM_BUF1_REG    = ADC_CFG1_DSM_BUF1;
1283   2              ADC_DSM_BUF2_REG    = ADC_CFG1_DSM_BUF2;
1284   2              ADC_DSM_BUF3_REG    = ADC_CFG1_DSM_BUF3;
1285   2      
1286   2              /* To select either Vssa or Vref to -ve input of DSM depending on
1287   2              *  the input  range selected.
1288   2              */
1289   2              #if(ADC_DEFAULT_INPUT_MODE)
1290   2                  #if (ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                              ADC_AMux_Select(1u);
                          #else
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 22  

1293   2                      ADC_AMux_Select(0u);
1294   2                  #endif /* ADC_IR_VSSA_TO_2VREF) */
1295   2              #endif /* ADC_DEFAULT_INPUT_MODE */
1296   2      
1297   2              /* Set the Conversion stop if resolution is above 16 bit and conversion
1298   2              *   mode is Single sample
1299   2              */
1300   2              #if(ADC_CFG1_RESOLUTION > 16 && \
1301   2                  ADC_CFG1_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                          ADC_stopConversion = 1u;
                      #endif /* Single sample with resolution above 16 bits. */
1304   2      
1305   2              ADC_CountsPerVolt = (int32)ADC_CFG1_COUNTS_PER_VOLT;
1306   2      
1307   2              ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG1_CP_CLK_DIVIDER, 1u);
1308   2      
1309   2              /* This is only valid if there is an internal clock */
1310   2              #if(ADC_DEFAULT_INTERNAL_CLK)
1311   2                  ADC_theACLK_SetDividerRegister(ADC_CFG1_ADC_CLK_DIVIDER, 1u);
1312   2              #endif /* ADC_DEFAULT_INTERNAL_CLK */
1313   2      
1314   2              #if(ADC_IRQ_REMOVE == 0u)
1315   2                  /* Set interrupt vector */
1316   2                  (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR1);
1317   2              #endif   /* End ADC_IRQ_REMOVE */
1318   2          }
1319   1      
1320   1          #if(ADC_DEFAULT_NUM_CONFIGS > 1)
                      if(config == 2u)
                      {
                          /* Second Config */
                          ADC_DEC_CR_REG      = ADC_CFG2_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG2_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG2_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG2_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG2_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG2_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG2_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG2_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG2_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG2_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG2_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG2_DSM_CR5;
                          ADC_DSM_CR6_REG     = ADC_CFG2_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG2_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG2_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG2_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG2_DSM_CR12;
                          ADC_DSM_CR14_REG    = ADC_CFG2_DSM_CR14;
                          ADC_DSM_CR15_REG    = ADC_CFG2_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG2_DSM_CR16;
                          ADC_DSM_CR17_REG    = ADC_CFG2_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS cirucit */
                          ADC_SetDSMRef0Reg(ADC_CFG2_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG2_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG2_DSM_REF3;
              
                          ADC_DSM_BUF0_REG    = ADC_CFG2_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG2_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG2_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG2_DSM_BUF3;
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 23  

              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
              
                          #if(ADC_DEFAULT_INPUT_MODE)
                              #if (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                          *   conversion mode is Single sample
                          */
                          #if(ADC_CFG2_RESOLUTION > 16 && \
                              ADC_CFG2_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits. */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG2_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG2_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG2_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR2);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 1 */
1391   1      
1392   1          #if(ADC_DEFAULT_NUM_CONFIGS > 2)
                      if(config == 3u)
                      {
                          /* Third Config */
                          ADC_DEC_CR_REG      = ADC_CFG3_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG3_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG3_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG3_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG3_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG3_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG3_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG3_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG3_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG3_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG3_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG3_DSM_CR5;
                          ADC_DSM_CR6_REG     = ADC_CFG3_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG3_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG3_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG3_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG3_DSM_CR12;
                          ADC_DSM_CR14_REG    = ADC_CFG3_DSM_CR14;
                          ADC_DSM_CR15_REG    = ADC_CFG3_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG3_DSM_CR16;
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 24  

                          ADC_DSM_CR17_REG    = ADC_CFG3_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
                          ADC_SetDSMRef0Reg(ADC_CFG3_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG3_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG3_DSM_REF3;
              
                          ADC_DSM_BUF0_REG    = ADC_CFG3_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG3_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG3_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG3_DSM_BUF3;
              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
                          #if(ADC_DEFAULT_INPUT_MODE)
                              #if (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                             conversion  mode is Single sample */
                          #if(ADC_CFG3_RESOLUTION > 16 && \
                              ADC_CFG3_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG3_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG3_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG3_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR3);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 2 */
1461   1      
1462   1          #if(ADC_DEFAULT_NUM_CONFIGS > 3)
                      if (config == 4u)
                      {
                          /* Fourth Config */
                          ADC_DEC_CR_REG      = ADC_CFG4_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG4_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG4_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG4_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG4_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG4_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG4_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG4_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG4_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG4_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG4_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG4_DSM_CR5;
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 25  

                          ADC_DSM_CR6_REG     = ADC_CFG4_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG4_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG4_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG4_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG4_DSM_CR12;
                          ADC_DSM_CR14_REG    = ADC_CFG4_DSM_CR14;
                          ADC_DSM_CR15_REG    = ADC_CFG4_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG4_DSM_CR16;
                          ADC_DSM_CR17_REG    = ADC_CFG4_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
                          ADC_SetDSMRef0Reg(ADC_CFG4_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG4_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG4_DSM_REF3;
              
                          ADC_DSM_BUF0_REG    = ADC_CFG4_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG4_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG4_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG4_DSM_BUF3;
              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
                          #if(ADC_DEFAULT_INPUT_MODE)
                              #if (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                             conversion mode is Single sample */
                          #if(ADC_CFG4_RESOLUTION > 16 && \
                              ADC_CFG4_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG4_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG4_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG4_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR4);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 3 */
1531   1      }
1532          
1533          
1534          /*******************************************************************************
1535          * Function Name: ADC_SelectCofiguration
1536          ********************************************************************************
1537          *
1538          * Summary:
1539          *  Sets one of up to four ADC configurations. Before setting the new
1540          *  configuration, the ADC is stopped and powered down. After setting
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 26  

1541          *  the new configuration, the ADC can be powered and conversion
1542          *  can be restarted depending up on the value of second parameter
1543          *  restart. If the value of this parameter is 1, then ADC will be
1544          *  restarted. If this value is zero, then user must call ADC_Start
1545          *  and ADC_StartConvert() to restart the conversion.
1546          *
1547          * Parameters:
1548          *  config:  configuration user wants to select.
1549          *           Valid range: 1..4
1550          *  restart:  Restart option. 1 means start the ADC and restart the conversion.
1551          *                            0 means do not start the ADC and conversion.
1552          *
1553          * Return:
1554          *  None
1555          *
1556          * Side Effects: 
1557          *  Enables internal interrupt.
1558          *
1559          *******************************************************************************/
1560          void ADC_SelectConfiguration(uint8 config, uint8 restart)
1561                                                        
1562          {
1563   1          /* Check whether the configuration number is valid or not */
1564   1          if((config > 0u) && (config <= ADC_DEFAULT_NUM_CONFIGS))
1565   1          {
1566   2              /* Set the flag to ensure Start() API doesn't override the 
1567   2                      *  selected configuration
1568   2                      */
1569   2              if(ADC_initVar == 0u)
1570   2              {
1571   3                  ADC_started = 1u;
1572   3              }
1573   2      
1574   2              /* Update the config flag */
1575   2              ADC_Config = config;
1576   2      
1577   2              /* Stop the ADC  */
1578   2              ADC_Stop();
1579   2      
1580   2              /* Set the  ADC registers based on the configuration */
1581   2              ADC_InitConfig(config);
1582   2      
1583   2              /* Compensate the gain */
1584   2              ADC_DEC_GVAL_REG = ADC_gcor[config - 1u].gval;
1585   2              CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, ADC_gcor[config - 1u].gcor);
1586   2      
1587   2              if(restart == 1u)
1588   2              {
1589   3                  /* Restart the ADC */
1590   3                  ADC_Start();
1591   3      
1592   3                  /* Restart the ADC conversion */
1593   3                  ADC_StartConvert();
1594   3              }
1595   2          }
1596   1          else
1597   1          {
1598   2              /* Halt CPU in debug mode if config is out of valid range */
1599   2              CYASSERT(0u != 0u);
1600   2          }
1601   1      }
1602          
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 27  

1603          
1604          /*******************************************************************************
1605          * Function Name: ADC_GainCompensation
1606          ********************************************************************************
1607          *
1608          * Summary:
1609          *  This API calculates the trim value and then store this to gcor structure.
1610          *
1611          * Parameters:
1612          *  inputRange:  input range for which trim value is to be calculated.
1613          *  IdealDecGain:  Ideal Decimator gain for the selected resolution and
1614          *                 conversion  mode.
1615          *  IdealOddDecGain:  Ideal odd decimation gain for the selected resolution and
1616                               conversion mode.
1617          *  resolution:  Resolution to select the proper flash location for trim value.
1618          *  config:      Specifies the configuration number
1619          *               Valid range: 1..4
1620          *
1621          * Return:
1622          *  None
1623          *
1624          *******************************************************************************/
1625          static void ADC_GainCompensation(uint8 inputRange, uint16 idealDecGain, uint16 idealOddDecGain,
1626                                        uint8 resolution, uint8 config) 
1627          {
1628   1          int8 flash;
1629   1              int32 normalised;
1630   1              uint16 gcorValue;
1631   1          uint32 gcorTmp;
1632   1      
1633   1          if((config > 0u) && (config <= ADC_DEFAULT_NUM_CONFIGS))
1634   1          {
1635   2              switch(inputRange)
1636   2              {
1637   3                  case ADC_IR_VNEG_VREF_DIFF:
1638   3                  case ADC_IR_VSSA_TO_2VREF:
1639   3                      /* Normalize the flash Value */
1640   3                      if(resolution > 15u)
1641   3                      {
1642   4                          flash = ADC_DEC_TRIM_VREF_DIFF_16_20;
1643   4                      }
1644   3                      else
1645   3                      {
1646   4                          flash = ADC_DEC_TRIM_VREF_DIFF_8_15;
1647   4                      }
1648   3                      break;
1649   3      
1650   3                  case ADC_IR_VNEG_VREF_2_DIFF:
1651   3                      /* Normalize the flash Value */
1652   3                      if(resolution > 15u)
1653   3                      {
1654   4                          flash = ADC_DEC_TRIM_VREF_2_DIFF_16_20;
1655   4                      }
1656   3                      else
1657   3                      {
1658   4                          flash = ADC_DEC_TRIM_VREF_2_DIFF_8_15;
1659   4                      }
1660   3                      break;
1661   3      
1662   3                  case ADC_IR_VNEG_VREF_4_DIFF:
1663   3                      /* Normalize the flash Value */
1664   3                      if(resolution > 15u)
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 28  

1665   3                      {
1666   4                          flash = ADC_DEC_TRIM_VREF_4_DIFF_16_20;
1667   4                      }
1668   3                      else
1669   3                      {
1670   4                          flash = ADC_DEC_TRIM_VREF_4_DIFF_8_15;
1671   4                      }
1672   3                      break;
1673   3      
1674   3                  case ADC_IR_VNEG_VREF_16_DIFF:
1675   3                      /* Normalize the flash Value */
1676   3                      if(resolution > 15u)
1677   3                      {
1678   4                          flash = ADC_DEC_TRIM_VREF_16_DIFF_16_20;
1679   4                      }
1680   3                      else
1681   3                      {
1682   4                          flash = ADC_DEC_TRIM_VREF_16_DIFF_8_15;
1683   4                      }
1684   3                      break;
1685   3      
1686   3                  default:
1687   3                      flash = 0;
1688   3                      break;
1689   3              }
1690   2      
1691   2              /* Add two values */
1692   2                      normalised = (int32)idealDecGain + ((int32)flash * 32);
1693   2              gcorTmp = (uint32)normalised * (uint32)idealOddDecGain;
1694   2              gcorValue = (uint16)(gcorTmp / ADC_IDEAL_GAIN_CONST);
1695   2      
1696   2              if (resolution < (ADC_MAX_GVAL - 1u))
1697   2              {
1698   3                  gcorValue = (gcorValue >> (ADC_MAX_GVAL - (resolution + 1u)));
1699   3                  ADC_gcor[config - 1u].gval = (resolution + 1u);
1700   3              }
1701   2              else
1702   2              {
1703   3                  /* Use all 16 bits */
1704   3                  ADC_gcor[config - 1u].gval = ADC_MAX_GVAL;
1705   3              }
1706   2      
1707   2              /* Save the gain correction register value */
1708   2              ADC_gcor[config - 1u].gcor = gcorValue;
1709   2          }
1710   1          else
1711   1          {
1712   2              /* Halt CPU in debug mode if config is out of valid range */
1713   2              CYASSERT(0u != 0u);
1714   2          }
1715   1      }
1716          
1717          
1718          /******************************************************************************
1719          * Function Name: ADC_SetDSMRef0Reg(uint8)
1720          ******************************************************************************
1721          *
1722          * Summary:
1723          *  This API sets the DSM_REF0 register. This is written for internal use.
1724          *
1725          * Parameters:
1726          *  value:  Value to be written to DSM_REF0 register.
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 29  

1727          *
1728          * Return:
1729          *  None
1730          *
1731          ******************************************************************************/
1732          static void ADC_SetDSMRef0Reg(uint8 value) 
1733          {
1734   1          uint8 enableInterrupts;
1735   1          enableInterrupts = CyEnterCriticalSection();
1736   1      
1737   1          /* Disable PRES, Enable power to VCMBUF0, REFBUF0 and REFBUF1, enable PRES */
1738   1          ADC_RESET_CR4_REG |= (ADC_IGNORE_PRESA1 | ADC_IGNORE_PRESD1);
1739   1          ADC_RESET_CR5_REG |= (ADC_IGNORE_PRESA2 | ADC_IGNORE_PRESD2);
1740   1          ADC_DSM_REF0_REG = value;
1741   1      
1742   1          /* Wait for 3 microseconds */
1743   1          CyDelayUs(ADC_PRES_DELAY_TIME);
1744   1          /* Enable the press circuit */
1745   1          ADC_RESET_CR4_REG &= (uint8)~(ADC_IGNORE_PRESA1 | ADC_IGNORE_PRESD1);
1746   1          ADC_RESET_CR5_REG &= (uint8)~(ADC_IGNORE_PRESA2 | ADC_IGNORE_PRESD2);
1747   1      
1748   1          CyExitCriticalSection(enableInterrupts);
1749   1      }
1750          
1751          
1752          /*******************************************************************************
1753          * Function Name: ADC_Read8
1754          ********************************************************************************
1755          *
1756          * Summary:
1757          *  This function simplifies getting results from the ADC when only a
1758          *  single reading is required. When called, it will start ADC
1759          *  conversions, wait for the conversion to be complete, stop ADC
1760          *  conversion and return the result. This is a blocking function and will
1761          *  not return until the result is ready.
1762          *
1763          * Parameters:
1764          *  None
1765          *
1766          * Return:
1767          *  int8:  ADC result.
1768          *
1769          *******************************************************************************/
1770          int8 ADC_Read8(void) 
1771          {
1772   1          int8 result;
1773   1      
1774   1          /* Clear pending conversion done status */
1775   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1776   1          ADC_StartConvert();
1777   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1778   1           result = ADC_GetResult8();
1779   1          ADC_StopConvert();
1780   1          
1781   1           return(result);
1782   1      }
1783          
1784          
1785          /*******************************************************************************
1786          * Function Name: ADC_Read16
1787          ********************************************************************************
1788          *
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 30  

1789          * Summary:
1790          *  This function simplifies getting results from the ADC when only a
1791          *  single reading is required. When called, it will start ADC
1792          *  conversions, wait for the conversion to be complete, stop ADC
1793          *  conversion and return the result. This is a blocking function and will
1794          *  not return until the result is ready.
1795          *
1796          * Parameters:
1797          *   void
1798          *
1799          * Return:
1800          *  int16:  ADC result.
1801          *
1802          *******************************************************************************/
1803          int16 ADC_Read16(void) 
1804          {
1805   1          int16 result;
1806   1      
1807   1          /* Clear pending conversion done status */
1808   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1809   1          ADC_StartConvert();
1810   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1811   1           result = ADC_GetResult16();
1812   1          ADC_StopConvert();
1813   1          
1814   1           return(result);
1815   1      }
1816          
1817          
1818          /*******************************************************************************
1819          * Function Name: ADC_Read32
1820          ********************************************************************************
1821          *
1822          * Summary:
1823          *  This function simplifies getting results from the ADC when only a
1824          *  single reading is required. When called, it will start ADC
1825          *  conversions, wait for the conversion to be complete, stop ADC
1826          *  conversion and return the result. This is a blocking function and will
1827          *  not return until the result is ready.
1828          *
1829          * Parameters:
1830          *  None
1831          *
1832          * Return:
1833          *  int32: ADC result.
1834          *
1835          *******************************************************************************/
1836          int32 ADC_Read32(void) 
1837          {
1838   1          int32 result;
1839   1          
1840   1          /* Clear pending conversion done status */
1841   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1842   1          ADC_StartConvert();
1843   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1844   1           result = ADC_GetResult32();
1845   1          ADC_StopConvert();
1846   1          
1847   1           return(result);
1848   1      }
1849          
1850          
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 31  

1851          /* [] END OF FILE */
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 32  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION ADC_Init (BEGIN)
                                           ; SOURCE LINE # 91
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 94
0000 900000      R     MOV     DPTR,#ADC_Config
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 95
0006 E4                CLR     A
0007 900000      R     MOV     DPTR,#ADC_convDone
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 97
000B 7F10              MOV     R7,#010H
000D 120000      E     LCALL   _ADC_Ext_CP_Clk_SetModeRegister
                                           ; SOURCE LINE # 101
0010 7F10              MOV     R7,#010H
0012 120000      E     LCALL   _ADC_theACLK_SetModeRegister
                                           ; SOURCE LINE # 106
0015 7D07              MOV     R5,#07H
0017 7F1D              MOV     R7,#01DH
0019 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 110
001C 905896            MOV     DPTR,#05896H
001F 7404              MOV     A,#04H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 111
0022 A3                INC     DPTR
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
0025 90589E            MOV     DPTR,#0589EH
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 113
0029 905B07            MOV     DPTR,#05B07H
002C E0                MOVX    A,@DPTR
002D 4418              ORL     A,#018H
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0030 905893            MOV     DPTR,#05893H
0033 E4                CLR     A
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 116
0035 905B88            MOV     DPTR,#05B88H
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 117
0039 A3                INC     DPTR
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 119
003B 905880            MOV     DPTR,#05880H
003E 740A              MOV     A,#0AH
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
0041 A3                INC     DPTR
0042 E4                CLR     A
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 124
0044 905883            MOV     DPTR,#05883H
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 33  

0048 905888            MOV     DPTR,#05888H
004B 7412              MOV     A,#012H
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 127
004E A3                INC     DPTR
004F 04                INC     A
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
0051 90588D            MOV     DPTR,#0588DH
0054 E4                CLR     A
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
0056 904E01            MOV     DPTR,#04E01H
0059 7414              MOV     A,#014H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 133
005C 900000      R     MOV     DPTR,#?_ADC_GainCompensation?BYTE+05H
005F 740C              MOV     A,#0CH
0061 F0                MOVX    @DPTR,A
0062 A3                INC     DPTR
0063 7401              MOV     A,#01H
0065 F0                MOVX    @DPTR,A
0066 7B00              MOV     R3,#00H
0068 7A80              MOV     R2,#080H
006A 7D6B              MOV     R5,#06BH
006C 7C8D              MOV     R4,#08DH
006E 7F02              MOV     R7,#02H
0070 120000      R     LCALL   _ADC_GainCompensation
                                           ; SOURCE LINE # 161
0073 900000      R     MOV     DPTR,#ADC_Config
0076 E0                MOVX    A,@DPTR
0077 75F003            MOV     B,#03H
007A A4                MUL     AB
007B 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
007D F582              MOV     DPL,A
007F E4                CLR     A
0080 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
0082 F583              MOV     DPH,A
0084 E0                MOVX    A,@DPTR
0085 904E0E            MOV     DPTR,#04E0EH
0088 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
0089 900000      R     MOV     DPTR,#ADC_Config
008C E0                MOVX    A,@DPTR
008D 75F003            MOV     B,#03H
0090 A4                MUL     AB
0091 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
0093 F582              MOV     DPL,A
0095 E4                CLR     A
0096 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0098 F583              MOV     DPH,A
009A E0                MOVX    A,@DPTR
009B FC                MOV     R4,A
009C A3                INC     DPTR
009D E0                MOVX    A,@DPTR
009E FD                MOV     R5,A
009F 7B02              MOV     R3,#02H
00A1 7A4E              MOV     R2,#04EH
00A3 790C              MOV     R1,#0CH
00A5 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 165
00A8 900000      R     MOV     DPTR,#ADC_Config
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 34  

00AB E0                MOVX    A,@DPTR
00AC FF                MOV     R7,A
00AD 120000      R     LCALL   _ADC_InitConfig
                                           ; SOURCE LINE # 166
00B0 22                RET     
             ; FUNCTION ADC_Init (END)

             ; FUNCTION ADC_Enable (BEGIN)
                                           ; SOURCE LINE # 186
                                           ; SOURCE LINE # 187
                                           ; SOURCE LINE # 190
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 193
0008 900000      R     MOV     DPTR,#ADC_Config
000B E0                MOVX    A,@DPTR
000C 900000      R     MOV     DPTR,#config
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 196
0010 9043AA            MOV     DPTR,#043AAH
0013 E0                MOVX    A,@DPTR
0014 4401              ORL     A,#01H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 197
0017 E0                MOVX    A,@DPTR
0018 4410              ORL     A,#010H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 200
001B 9043BA            MOV     DPTR,#043BAH
001E E0                MOVX    A,@DPTR
001F 4401              ORL     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 201
0022 E0                MOVX    A,@DPTR
0023 4410              ORL     A,#010H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 204
0026 9046F8            MOV     DPTR,#046F8H
0029 E0                MOVX    A,@DPTR
002A 4402              ORL     A,#02H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 205
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F 4402              ORL     A,#02H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 207
0032 905891            MOV     DPTR,#05891H
0035 E0                MOVX    A,@DPTR
0036 4403              ORL     A,#03H
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 268
                                           ; SOURCE LINE # 270
0039         ?C0002:
                                           ; SOURCE LINE # 273
0039 7F03              MOV     R7,#03H
003B 7E00              MOV     R6,#00H
003D 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 276
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 35  

0040 9046F8            MOV     DPTR,#046F8H
0043 E0                MOVX    A,@DPTR
0044 54FD              ANL     A,#0FDH
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
0047 A3                INC     DPTR
0048 E0                MOVX    A,@DPTR
0049 54FD              ANL     A,#0FDH
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
004C 905877            MOV     DPTR,#05877H
004F E0                MOVX    A,@DPTR
0050 4406              ORL     A,#06H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 283
0053 905882            MOV     DPTR,#05882H
0056 747A              MOV     A,#07AH
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 287
0059 9043A1            MOV     DPTR,#043A1H
005C E0                MOVX    A,@DPTR
005D 4401              ORL     A,#01H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 288
0060 9043B1            MOV     DPTR,#043B1H
0063 E0                MOVX    A,@DPTR
0064 4401              ORL     A,#01H
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 292
0067 9043A2            MOV     DPTR,#043A2H
006A E0                MOVX    A,@DPTR
006B 4402              ORL     A,#02H
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 293
006E 9043B2            MOV     DPTR,#043B2H
0071 E0                MOVX    A,@DPTR
0072 4402              ORL     A,#02H
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
0075 9044DB            MOV     DPTR,#044DBH
0078 7420              MOV     A,#020H
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 299
007B 9044C3            MOV     DPTR,#044C3H
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 302
007F 900000      R     MOV     DPTR,#enableInterrupts
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
0084 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 304
0087 22                RET     
             ; FUNCTION ADC_Enable (END)

             ; FUNCTION ADC_Start (BEGIN)
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
                                           ; SOURCE LINE # 336
0000 900000      R     MOV     DPTR,#ADC_initVar
0003 E0                MOVX    A,@DPTR
0004 700F              JNZ     ?C0004
                                           ; SOURCE LINE # 337
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 36  

                                           ; SOURCE LINE # 338
0006 900000      R     MOV     DPTR,#ADC_started
0009 E0                MOVX    A,@DPTR
000A 7003              JNZ     ?C0005
                                           ; SOURCE LINE # 339
                                           ; SOURCE LINE # 340
000C 120000      R     LCALL   ADC_Init
                                           ; SOURCE LINE # 341
000F         ?C0005:
                                           ; SOURCE LINE # 342
000F 900000      R     MOV     DPTR,#ADC_initVar
0012 7401              MOV     A,#01H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 343
0015         ?C0004:
                                           ; SOURCE LINE # 346
0015 120000      R     LCALL   ADC_Enable
                                           ; SOURCE LINE # 347
0018 22                RET     
             ; FUNCTION ADC_Start (END)

             ; FUNCTION ADC_Stop (BEGIN)
                                           ; SOURCE LINE # 367
                                           ; SOURCE LINE # 368
                                           ; SOURCE LINE # 370
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 373
0008 904E00            MOV     DPTR,#04E00H
000B E0                MOVX    A,@DPTR
000C 54FE              ANL     A,#0FEH
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 374
000F A3                INC     DPTR
0010 E0                MOVX    A,@DPTR
0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 378
0014 9046F8            MOV     DPTR,#046F8H
0017 E0                MOVX    A,@DPTR
0018 4402              ORL     A,#02H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 379
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D 4402              ORL     A,#02H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 381
0020 905891            MOV     DPTR,#05891H
0023 E0                MOVX    A,@DPTR
0024 54FC              ANL     A,#0FCH
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 382
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 54F7              ANL     A,#0F7H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 385
002C 7F03              MOV     R7,#03H
002E 7E00              MOV     R6,#00H
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 37  

0030 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 388
0033 9046F8            MOV     DPTR,#046F8H
0036 E0                MOVX    A,@DPTR
0037 54FD              ANL     A,#0FDH
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 389
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C 54FD              ANL     A,#0FDH
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 392
003F 9043AA            MOV     DPTR,#043AAH
0042 E0                MOVX    A,@DPTR
0043 54EF              ANL     A,#0EFH
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 395
0046 E0                MOVX    A,@DPTR
0047 54FE              ANL     A,#0FEH
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 398
004A 9043BA            MOV     DPTR,#043BAH
004D E0                MOVX    A,@DPTR
004E 54FE              ANL     A,#0FEH
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 399
0051 E0                MOVX    A,@DPTR
0052 54EF              ANL     A,#0EFH
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 402
0055 905877            MOV     DPTR,#05877H
0058 E0                MOVX    A,@DPTR
0059 54F9              ANL     A,#0F9H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 406
005C 9043A1            MOV     DPTR,#043A1H
005F E0                MOVX    A,@DPTR
0060 54FE              ANL     A,#0FEH
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 407
0063 9043B1            MOV     DPTR,#043B1H
0066 E0                MOVX    A,@DPTR
0067 54FE              ANL     A,#0FEH
0069 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 411
006A 905882            MOV     DPTR,#05882H
006D E0                MOVX    A,@DPTR
006E 54F7              ANL     A,#0F7H
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 413
0071 9043A2            MOV     DPTR,#043A2H
0074 E0                MOVX    A,@DPTR
0075 54FD              ANL     A,#0FDH
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 414
0078 9043B2            MOV     DPTR,#043B2H
007B E0                MOVX    A,@DPTR
007C 54FD              ANL     A,#0FDH
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 416
007F 900000      R     MOV     DPTR,#enableInterrupts
0082 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 38  

0083 FF                MOV     R7,A
0084 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 417
0087 22                RET     
             ; FUNCTION ADC_Stop (END)

             ; FUNCTION _ADC_SetBufferGain (BEGIN)
                                           ; SOURCE LINE # 434
;---- Variable 'gain' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 435
                                           ; SOURCE LINE # 437
0000 90589B            MOV     DPTR,#0589BH
0003 E0                MOVX    A,@DPTR
0004 54F3              ANL     A,#0F3H
0006 FE                MOV     R6,A
;---- Variable 'tmpReg' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 438
0007 EF                MOV     A,R7
0008 25E0              ADD     A,ACC
000A 25E0              ADD     A,ACC
000C 540C              ANL     A,#0CH
000E 4E                ORL     A,R6
000F FE                MOV     R6,A
                                           ; SOURCE LINE # 439
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 440
0011 22                RET     
             ; FUNCTION _ADC_SetBufferGain (END)

             ; FUNCTION _ADC_SetCoherency (BEGIN)
                                           ; SOURCE LINE # 470
;---- Variable 'coherency' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 471
                                           ; SOURCE LINE # 474
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 54FC              ANL     A,#0FCH
0006 FE                MOV     R6,A
;---- Variable 'tmpReg' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 475
0007 EF                MOV     A,R7
0008 5403              ANL     A,#03H
000A 4E                ORL     A,R6
000B FE                MOV     R6,A
                                           ; SOURCE LINE # 476
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 477
000D 22                RET     
             ; FUNCTION _ADC_SetCoherency (END)

             ; FUNCTION _ADC_SetGCOR (BEGIN)
                                           ; SOURCE LINE # 510
0000 900000      R     MOV     DPTR,#gainAdjust
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 511
                                           ; SOURCE LINE # 516
0006 900000      R     MOV     DPTR,#ADC_Config
0009 E0                MOVX    A,@DPTR
000A 75F003            MOV     B,#03H
000D A4                MUL     AB
000E 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
0010 F582              MOV     DPL,A
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 39  

0012 E4                CLR     A
0013 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0015 F583              MOV     DPH,A
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B 900000      R     MOV     DPTR,#tmpReg
001E CF                XCH     A,R7
001F F0                MOVX    @DPTR,A
0020 A3                INC     DPTR
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 517
0023 900000      R     MOV     DPTR,#tmpReg
0026 E0                MOVX    A,@DPTR
0027 FC                MOV     R4,A
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FD                MOV     R5,A
002B E4                CLR     A
002C 120000      E     LCALL   ?C?FCASTI
002F E4                CLR     A
0030 FB                MOV     R3,A
0031 FA                MOV     R2,A
0032 F9                MOV     R1,A
0033 7847              MOV     R0,#047H
0035 120000      E     LCALL   ?C?FPDIV
0038 900000      R     MOV     DPTR,#tmpValue
003B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 518
003E 900000      R     MOV     DPTR,#tmpValue
0041 E0                MOVX    A,@DPTR
0042 FC                MOV     R4,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FD                MOV     R5,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
0048 FE                MOV     R6,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C 900000      R     MOV     DPTR,#gainAdjust
004F E0                MOVX    A,@DPTR
0050 F8                MOV     R0,A
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 F9                MOV     R1,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FA                MOV     R2,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FB                MOV     R3,A
005A 120000      E     LCALL   ?C?FPMUL
005D 900000      R     MOV     DPTR,#tmpValue
0060 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 520
0063 7FB9              MOV     R7,#0B9H
0065 7EFC              MOV     R6,#0FCH
0067 7DFF              MOV     R5,#0FFH
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 40  

0069 7C3F              MOV     R4,#03FH
006B 900000      R     MOV     DPTR,#tmpValue
006E E0                MOVX    A,@DPTR
006F F8                MOV     R0,A
0070 A3                INC     DPTR
0071 E0                MOVX    A,@DPTR
0072 F9                MOV     R1,A
0073 A3                INC     DPTR
0074 E0                MOVX    A,@DPTR
0075 FA                MOV     R2,A
0076 A3                INC     DPTR
0077 E0                MOVX    A,@DPTR
0078 FB                MOV     R3,A
0079 120000      E     LCALL   ?C?FPCMP3
007C 600A              JZ      ?C0010
007E 4008              JC      ?C0010
                                           ; SOURCE LINE # 521
                                           ; SOURCE LINE # 522
0080 900000      R     MOV     DPTR,#status
0083 7401              MOV     A,#01H
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
0086 8064              SJMP    ?C0011
0088         ?C0010:
                                           ; SOURCE LINE # 525
                                           ; SOURCE LINE # 526
0088 900000      R     MOV     DPTR,#tmpValue
008B E0                MOVX    A,@DPTR
008C FC                MOV     R4,A
008D A3                INC     DPTR
008E E0                MOVX    A,@DPTR
008F FD                MOV     R5,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 FE                MOV     R6,A
0093 A3                INC     DPTR
0094 E0                MOVX    A,@DPTR
0095 FF                MOV     R7,A
0096 E4                CLR     A
0097 FB                MOV     R3,A
0098 FA                MOV     R2,A
0099 F9                MOV     R1,A
009A 7847              MOV     R0,#047H
009C 120000      E     LCALL   ?C?FPMUL
009F 900000      R     MOV     DPTR,#tmpValue
00A2 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 527
00A5 900000      R     MOV     DPTR,#tmpValue
00A8 E0                MOVX    A,@DPTR
00A9 FC                MOV     R4,A
00AA A3                INC     DPTR
00AB E0                MOVX    A,@DPTR
00AC FD                MOV     R5,A
00AD A3                INC     DPTR
00AE E0                MOVX    A,@DPTR
00AF FE                MOV     R6,A
00B0 A3                INC     DPTR
00B1 E0                MOVX    A,@DPTR
00B2 FF                MOV     R7,A
00B3 120000      E     LCALL   ?C?CASTF
00B6 900000      R     MOV     DPTR,#tmpReg
00B9 EE                MOV     A,R6
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 41  

00BA F0                MOVX    @DPTR,A
00BB FC                MOV     R4,A
00BC A3                INC     DPTR
00BD EF                MOV     A,R7
00BE F0                MOVX    @DPTR,A
00BF FD                MOV     R5,A
                                           ; SOURCE LINE # 528
00C0 7B02              MOV     R3,#02H
00C2 7A4E              MOV     R2,#04EH
00C4 790C              MOV     R1,#0CH
00C6 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 530
00C9 900000      R     MOV     DPTR,#tmpReg
00CC E0                MOVX    A,@DPTR
00CD FE                MOV     R6,A
00CE A3                INC     DPTR
00CF E0                MOVX    A,@DPTR
00D0 FF                MOV     R7,A
00D1 900000      R     MOV     DPTR,#ADC_Config
00D4 E0                MOVX    A,@DPTR
00D5 75F003            MOV     B,#03H
00D8 A4                MUL     AB
00D9 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
00DB F582              MOV     DPL,A
00DD E4                CLR     A
00DE 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
00E0 F583              MOV     DPH,A
00E2 EE                MOV     A,R6
00E3 F0                MOVX    @DPTR,A
00E4 A3                INC     DPTR
00E5 EF                MOV     A,R7
00E6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 532
00E7 E4                CLR     A
00E8 900000      R     MOV     DPTR,#status
00EB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 534
00EC         ?C0011:
                                           ; SOURCE LINE # 535
00EC 900000      R     MOV     DPTR,#status
00EF E0                MOVX    A,@DPTR
00F0 FF                MOV     R7,A
                                           ; SOURCE LINE # 536
00F1         ?C0012:
00F1 22                RET     
             ; FUNCTION _ADC_SetGCOR (END)

             ; FUNCTION ADC_ReadGCOR (BEGIN)
                                           ; SOURCE LINE # 557
                                           ; SOURCE LINE # 558
                                           ; SOURCE LINE # 562
0000 904E0E            MOV     DPTR,#04E0EH
0003 E0                MOVX    A,@DPTR
0004 900000      R     MOV     DPTR,#gValue
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 563
0008 7B02              MOV     R3,#02H
000A 7A4E              MOV     R2,#04EH
000C 790C              MOV     R1,#0CH
000E 120000      E     LCALL   _cyread16_nodpx
;---- Variable 'gcorValue' assigned to Register 'R4/R5' ----
0011 AD07              MOV     R5,AR7
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 42  

0013 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 565
0015 900000      R     MOV     DPTR,#gValue
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A C3                CLR     C
001B 940F              SUBB    A,#0FH
001D 5015              JNC     ?C0013
                                           ; SOURCE LINE # 566
                                           ; SOURCE LINE # 567
001F C3                CLR     C
0020 740F              MOV     A,#0FH
0022 9F                SUBB    A,R7
0023 FF                MOV     R7,A
0024 ED                MOV     A,R5
0025 A807              MOV     R0,AR7
0027 08                INC     R0
0028 8005              SJMP    ?C0091
002A         ?C0090:
002A C3                CLR     C
002B 33                RLC     A
002C CE                XCH     A,R6
002D 33                RLC     A
002E CE                XCH     A,R6
002F         ?C0091:
002F D8F9              DJNZ    R0,?C0090
0031 FD                MOV     R5,A
0032 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 568
0034         ?C0013:
                                           ; SOURCE LINE # 570
0034 AE04              MOV     R6,AR4
0036 AF05              MOV     R7,AR5
                                           ; SOURCE LINE # 571
0038         ?C0014:
0038 22                RET     
             ; FUNCTION ADC_ReadGCOR (END)

             ; FUNCTION ADC_StartConvert (BEGIN)
                                           ; SOURCE LINE # 591
                                           ; SOURCE LINE # 592
                                           ; SOURCE LINE # 594
0000 904E00            MOV     DPTR,#04E00H
0003 E0                MOVX    A,@DPTR
0004 4401              ORL     A,#01H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 595
0007 22                RET     
             ; FUNCTION ADC_StartConvert (END)

             ; FUNCTION ADC_StopConvert (BEGIN)
                                           ; SOURCE LINE # 614
                                           ; SOURCE LINE # 615
                                           ; SOURCE LINE # 617
0000 904E00            MOV     DPTR,#04E00H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 618
0007 22                RET     
             ; FUNCTION ADC_StopConvert (END)

C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 43  

             ; FUNCTION _ADC_IsEndConversion (BEGIN)
                                           ; SOURCE LINE # 649
;---- Variable 'status' assigned to Register 'R6' ----
;---- Variable 'retMode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 650
0000         ?C0019:
                                           ; SOURCE LINE # 654
                                           ; SOURCE LINE # 658
0000 900000      R     MOV     DPTR,#ADC_stopConversion
0003 E0                MOVX    A,@DPTR
0004 6007              JZ      ?C0020
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0006 900000      R     MOV     DPTR,#ADC_convDone
0009 E0                MOVX    A,@DPTR
000A FE                MOV     R6,A
                                           ; SOURCE LINE # 661
000B 8007              SJMP    ?C0017
000D         ?C0020:
                                           ; SOURCE LINE # 663
                                           ; SOURCE LINE # 664
000D 904E01            MOV     DPTR,#04E01H
0010 E0                MOVX    A,@DPTR
0011 5401              ANL     A,#01H
0013 FE                MOV     R6,A
                                           ; SOURCE LINE # 665
                                           ; SOURCE LINE # 666
0014         ?C0017:
0014 EE                MOV     A,R6
0015 6401              XRL     A,#01H
0017 6003              JZ      ?C0018
0019 EF                MOV     A,R7
001A 60E4              JZ      ?C0019
001C         ?C0018:
                                           ; SOURCE LINE # 668
001C AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 669
001E         ?C0023:
001E 22                RET     
             ; FUNCTION _ADC_IsEndConversion (END)

             ; FUNCTION ADC_GetResult8 (BEGIN)
                                           ; SOURCE LINE # 696
                                           ; SOURCE LINE # 697
                                           ; SOURCE LINE # 702
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 5403              ANL     A,#03H
0006 FF                MOV     R7,A
;---- Variable 'coherency' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 704
0007 904E10            MOV     DPTR,#04E10H
000A E0                MOVX    A,@DPTR
000B FE                MOV     R6,A
;---- Variable 'result' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 706
000C EF                MOV     A,R7
000D B40205            CJNE    A,#02H,?C0024
                                           ; SOURCE LINE # 707
                                           ; SOURCE LINE # 708
0010 A3                INC     DPTR
0011 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 44  

0012 FD                MOV     R5,A
                                           ; SOURCE LINE # 709
0013 8009              SJMP    ?C0025
0015         ?C0024:
                                           ; SOURCE LINE # 710
0015 EF                MOV     A,R7
0016 B40305            CJNE    A,#03H,?C0025
                                           ; SOURCE LINE # 711
                                           ; SOURCE LINE # 712
0019 904E12            MOV     DPTR,#04E12H
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
                                           ; SOURCE LINE # 713
                                           ; SOURCE LINE # 715
                                           ; SOURCE LINE # 716
001E         ?C0025:
                                           ; SOURCE LINE # 718
001E 900000      R     MOV     DPTR,#ADC_stopConversion
0021 E0                MOVX    A,@DPTR
0022 6005              JZ      ?C0028
                                           ; SOURCE LINE # 719
                                           ; SOURCE LINE # 720
0024 E4                CLR     A
0025 900000      R     MOV     DPTR,#ADC_convDone
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 721
0029         ?C0028:
                                           ; SOURCE LINE # 722
0029 AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 723
002B         ?C0029:
002B 22                RET     
             ; FUNCTION ADC_GetResult8 (END)

             ; FUNCTION ADC_GetResult16 (BEGIN)
                                           ; SOURCE LINE # 750
                                           ; SOURCE LINE # 751
                                           ; SOURCE LINE # 756
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 5403              ANL     A,#03H
0006 900000      R     MOV     DPTR,#coherency
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 758
000A E0                MOVX    A,@DPTR
000B D3                SETB    C
000C 9401              SUBB    A,#01H
000E 5021              JNC     ?C0030
                                           ; SOURCE LINE # 759
                                           ; SOURCE LINE # 761
0010 904E11            MOV     DPTR,#04E11H
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#result
0018 E4                CLR     A
0019 F0                MOVX    @DPTR,A
001A A3                INC     DPTR
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 762
001D E0                MOVX    A,@DPTR
001E FE                MOV     R6,A
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 45  

001F 904E10            MOV     DPTR,#04E10H
0022 E0                MOVX    A,@DPTR
0023 FD                MOV     R5,A
0024 EE                MOV     A,R6
0025 ED                MOV     A,R5
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#result
002A EE                MOV     A,R6
002B F0                MOVX    @DPTR,A
002C A3                INC     DPTR
002D EF                MOV     A,R7
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 766
002F 801B              SJMP    ?C0031
0031         ?C0030:
                                           ; SOURCE LINE # 768
                                           ; SOURCE LINE # 770
0031 7B02              MOV     R3,#02H
0033 7A4E              MOV     R2,#04EH
0035 7910              MOV     R1,#010H
0037 120000      E     LCALL   _cyread16_nodpx
003A 900000      R     MOV     DPTR,#result
003D EE                MOV     A,R6
003E F0                MOVX    @DPTR,A
003F A3                INC     DPTR
0040 EF                MOV     A,R7
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 775
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 B40305            CJNE    A,#03H,?C0031
                                           ; SOURCE LINE # 776
                                           ; SOURCE LINE # 777
0047 904E12            MOV     DPTR,#04E12H
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
                                           ; SOURCE LINE # 778
                                           ; SOURCE LINE # 779
004C         ?C0031:
                                           ; SOURCE LINE # 781
004C 900000      R     MOV     DPTR,#ADC_stopConversion
004F E0                MOVX    A,@DPTR
0050 6005              JZ      ?C0033
                                           ; SOURCE LINE # 782
                                           ; SOURCE LINE # 783
0052 E4                CLR     A
0053 900000      R     MOV     DPTR,#ADC_convDone
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 784
0057         ?C0033:
                                           ; SOURCE LINE # 786
0057 900000      R     MOV     DPTR,#result
005A E0                MOVX    A,@DPTR
005B FE                MOV     R6,A
005C A3                INC     DPTR
005D E0                MOVX    A,@DPTR
005E FF                MOV     R7,A
                                           ; SOURCE LINE # 787
005F         ?C0034:
005F 22                RET     
             ; FUNCTION ADC_GetResult16 (END)

C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 46  

             ; FUNCTION ADC_GetResult32 (BEGIN)
                                           ; SOURCE LINE # 810
                                           ; SOURCE LINE # 811
                                           ; SOURCE LINE # 819
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 5403              ANL     A,#03H
0006 900000      R     MOV     DPTR,#coherency
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 821
000A E0                MOVX    A,@DPTR
000B D3                SETB    C
000C 9401              SUBB    A,#01H
000E 4003              JC      $ + 5H
0010 020000      R     LJMP    ?C0035
                                           ; SOURCE LINE # 822
                                           ; SOURCE LINE # 824
0013 904E12            MOV     DPTR,#04E12H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 E4                CLR     A
0019 FC                MOV     R4,A
001A FD                MOV     R5,A
001B FE                MOV     R6,A
001C 900000      R     MOV     DPTR,#result
001F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 825
0022 900000      R     MOV     DPTR,#result
0025 E0                MOVX    A,@DPTR
0026 FC                MOV     R4,A
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 FD                MOV     R5,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C FE                MOV     R6,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F 5480              ANL     A,#080H
0031 FF                MOV     R7,A
0032 E4                CLR     A
0033 EF                MOV     A,R7
0034 6016              JZ      ?C0036
                                           ; SOURCE LINE # 826
                                           ; SOURCE LINE # 827
0036 900000      R     MOV     DPTR,#result
0039 E0                MOVX    A,@DPTR
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 74FF              MOV     A,#0FFH
0043 FE                MOV     R6,A
0044 ED                MOV     A,R5
0045 EC                MOV     A,R4
0046 900000      R     MOV     DPTR,#result
0049 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 828
004C         ?C0036:
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 47  

                                           ; SOURCE LINE # 829
004C 900000      R     MOV     DPTR,#result
004F E0                MOVX    A,@DPTR
0050 FC                MOV     R4,A
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 FD                MOV     R5,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FE                MOV     R6,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A 7808              MOV     R0,#08H
005C 120000      E     LCALL   ?C?LSHL
005F A804              MOV     R0,AR4
0061 A905              MOV     R1,AR5
0063 AA06              MOV     R2,AR6
0065 AB07              MOV     R3,AR7
0067 904E11            MOV     DPTR,#04E11H
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C E4                CLR     A
006D EB                MOV     A,R3
006E 4F                ORL     A,R7
006F FF                MOV     R7,A
0070 EA                MOV     A,R2
0071 FE                MOV     R6,A
0072 E9                MOV     A,R1
0073 FD                MOV     R5,A
0074 E8                MOV     A,R0
0075 FC                MOV     R4,A
0076 900000      R     MOV     DPTR,#result
0079 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 830
007C 900000      R     MOV     DPTR,#result
007F E0                MOVX    A,@DPTR
0080 FC                MOV     R4,A
0081 A3                INC     DPTR
0082 E0                MOVX    A,@DPTR
0083 FD                MOV     R5,A
0084 A3                INC     DPTR
0085 E0                MOVX    A,@DPTR
0086 FE                MOV     R6,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A 7808              MOV     R0,#08H
008C 120000      E     LCALL   ?C?LSHL
008F A804              MOV     R0,AR4
0091 A905              MOV     R1,AR5
0093 AA06              MOV     R2,AR6
0095 AB07              MOV     R3,AR7
0097 904E10            MOV     DPTR,#04E10H
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C E4                CLR     A
009D EB                MOV     A,R3
009E 4F                ORL     A,R7
009F FF                MOV     R7,A
00A0 EA                MOV     A,R2
00A1 FE                MOV     R6,A
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 48  

00A2 E9                MOV     A,R1
00A3 FD                MOV     R5,A
00A4 E8                MOV     A,R0
00A5 FC                MOV     R4,A
00A6 900000      R     MOV     DPTR,#result
00A9 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 835
00AC 020000      R     LJMP    ?C0037
00AF         ?C0035:
                                           ; SOURCE LINE # 836
00AF 900000      R     MOV     DPTR,#coherency
00B2 E0                MOVX    A,@DPTR
00B3 6402              XRL     A,#02H
00B5 707C              JNZ     ?C0038
                                           ; SOURCE LINE # 837
                                           ; SOURCE LINE # 839
00B7 904E12            MOV     DPTR,#04E12H
00BA E0                MOVX    A,@DPTR
00BB FF                MOV     R7,A
00BC E4                CLR     A
00BD FC                MOV     R4,A
00BE FD                MOV     R5,A
00BF FE                MOV     R6,A
00C0 900000      R     MOV     DPTR,#result
00C3 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 840
00C6 900000      R     MOV     DPTR,#result
00C9 E0                MOVX    A,@DPTR
00CA FC                MOV     R4,A
00CB A3                INC     DPTR
00CC E0                MOVX    A,@DPTR
00CD FD                MOV     R5,A
00CE A3                INC     DPTR
00CF E0                MOVX    A,@DPTR
00D0 FE                MOV     R6,A
00D1 A3                INC     DPTR
00D2 E0                MOVX    A,@DPTR
00D3 5480              ANL     A,#080H
00D5 FF                MOV     R7,A
00D6 E4                CLR     A
00D7 EF                MOV     A,R7
00D8 6016              JZ      ?C0039
                                           ; SOURCE LINE # 841
                                           ; SOURCE LINE # 842
00DA 900000      R     MOV     DPTR,#result
00DD E0                MOVX    A,@DPTR
00DE A3                INC     DPTR
00DF E0                MOVX    A,@DPTR
00E0 A3                INC     DPTR
00E1 E0                MOVX    A,@DPTR
00E2 A3                INC     DPTR
00E3 E0                MOVX    A,@DPTR
00E4 FF                MOV     R7,A
00E5 74FF              MOV     A,#0FFH
00E7 FE                MOV     R6,A
00E8 ED                MOV     A,R5
00E9 EC                MOV     A,R4
00EA 900000      R     MOV     DPTR,#result
00ED 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 843
00F0         ?C0039:
                                           ; SOURCE LINE # 844
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 49  

00F0 7B02              MOV     R3,#02H
00F2 7A4E              MOV     R2,#04EH
00F4 7910              MOV     R1,#010H
00F6 120000      E     LCALL   _cyread16_nodpx
00F9 E4                CLR     A
00FA FC                MOV     R4,A
00FB FD                MOV     R5,A
00FC C004              PUSH    AR4
00FE C005              PUSH    AR5
0100 C006              PUSH    AR6
0102 C007              PUSH    AR7
0104 900000      R     MOV     DPTR,#result
0107 E0                MOVX    A,@DPTR
0108 FC                MOV     R4,A
0109 A3                INC     DPTR
010A E0                MOVX    A,@DPTR
010B FD                MOV     R5,A
010C A3                INC     DPTR
010D E0                MOVX    A,@DPTR
010E FE                MOV     R6,A
010F A3                INC     DPTR
0110 E0                MOVX    A,@DPTR
0111 FF                MOV     R7,A
0112 7810              MOV     R0,#010H
0114 120000      E     LCALL   ?C?LSHL
0117 D003              POP     AR3
0119 D002              POP     AR2
011B D001              POP     AR1
011D D000              POP     AR0
011F EF                MOV     A,R7
0120 4B                ORL     A,R3
0121 FF                MOV     R7,A
0122 EE                MOV     A,R6
0123 4A                ORL     A,R2
0124 FE                MOV     R6,A
0125 ED                MOV     A,R5
0126 49                ORL     A,R1
0127 FD                MOV     R5,A
0128 EC                MOV     A,R4
0129 48                ORL     A,R0
012A FC                MOV     R4,A
012B 900000      R     MOV     DPTR,#result
012E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 850
0131 8067              SJMP    ?C0037
0133         ?C0038:
                                           ; SOURCE LINE # 852
                                           ; SOURCE LINE # 855
0133 7B02              MOV     R3,#02H
0135 7A4E              MOV     R2,#04EH
0137 7910              MOV     R1,#010H
0139 120000      E     LCALL   _cyread16_nodpx
013C E4                CLR     A
013D FC                MOV     R4,A
013E FD                MOV     R5,A
013F 900000      R     MOV     DPTR,#result
0142 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 856
0145 904E12            MOV     DPTR,#04E12H
0148 E0                MOVX    A,@DPTR
0149 FF                MOV     R7,A
014A 900000      R     MOV     DPTR,#tmp
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 50  

014D E4                CLR     A
014E F0                MOVX    @DPTR,A
014F A3                INC     DPTR
0150 EF                MOV     A,R7
0151 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 857
0152 900000      R     MOV     DPTR,#tmp
0155 E0                MOVX    A,@DPTR
0156 FE                MOV     R6,A
0157 A3                INC     DPTR
0158 E0                MOVX    A,@DPTR
0159 FF                MOV     R7,A
015A 30E709            JNB     ACC.7,?C0041
                                           ; SOURCE LINE # 858
                                           ; SOURCE LINE # 859
015D 900000      R     MOV     DPTR,#tmp
0160 74FF              MOV     A,#0FFH
0162 F0                MOVX    @DPTR,A
0163 A3                INC     DPTR
0164 EF                MOV     A,R7
0165 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 860
0166         ?C0041:
                                           ; SOURCE LINE # 861
0166 900000      R     MOV     DPTR,#result
0169 E0                MOVX    A,@DPTR
016A F8                MOV     R0,A
016B A3                INC     DPTR
016C E0                MOVX    A,@DPTR
016D F9                MOV     R1,A
016E A3                INC     DPTR
016F E0                MOVX    A,@DPTR
0170 FA                MOV     R2,A
0171 A3                INC     DPTR
0172 E0                MOVX    A,@DPTR
0173 FB                MOV     R3,A
0174 C000              PUSH    AR0
0176 900000      R     MOV     DPTR,#tmp
0179 E0                MOVX    A,@DPTR
017A FE                MOV     R6,A
017B A3                INC     DPTR
017C E0                MOVX    A,@DPTR
017D FF                MOV     R7,A
017E E4                CLR     A
017F FC                MOV     R4,A
0180 FD                MOV     R5,A
0181 7810              MOV     R0,#010H
0183 120000      E     LCALL   ?C?LSHL
0186 D000              POP     AR0
0188 EB                MOV     A,R3
0189 4F                ORL     A,R7
018A FF                MOV     R7,A
018B EA                MOV     A,R2
018C 4E                ORL     A,R6
018D FE                MOV     R6,A
018E E9                MOV     A,R1
018F 4D                ORL     A,R5
0190 FD                MOV     R5,A
0191 E8                MOV     A,R0
0192 4C                ORL     A,R4
0193 FC                MOV     R4,A
0194 900000      R     MOV     DPTR,#result
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 51  

0197 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 866
019A         ?C0037:
                                           ; SOURCE LINE # 868
019A 900000      R     MOV     DPTR,#ADC_stopConversion
019D E0                MOVX    A,@DPTR
019E 6005              JZ      ?C0042
                                           ; SOURCE LINE # 869
                                           ; SOURCE LINE # 870
01A0 E4                CLR     A
01A1 900000      R     MOV     DPTR,#ADC_convDone
01A4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 871
01A5         ?C0042:
                                           ; SOURCE LINE # 873
01A5 900000      R     MOV     DPTR,#result
01A8 E0                MOVX    A,@DPTR
01A9 FC                MOV     R4,A
01AA A3                INC     DPTR
01AB E0                MOVX    A,@DPTR
01AC FD                MOV     R5,A
01AD A3                INC     DPTR
01AE E0                MOVX    A,@DPTR
01AF FE                MOV     R6,A
01B0 A3                INC     DPTR
01B1 E0                MOVX    A,@DPTR
01B2 FF                MOV     R7,A
                                           ; SOURCE LINE # 874
01B3         ?C0043:
01B3 22                RET     
             ; FUNCTION ADC_GetResult32 (END)

             ; FUNCTION _ADC_SetOffset (BEGIN)
                                           ; SOURCE LINE # 903
;---- Variable 'offset' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 904
                                           ; SOURCE LINE # 906
0000 900000      R     MOV     DPTR,#ADC_Offset
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 907
0006 22                RET     
             ; FUNCTION _ADC_SetOffset (END)

             ; FUNCTION _ADC_SetGain (BEGIN)
                                           ; SOURCE LINE # 938
;---- Variable 'adcGain' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 939
                                           ; SOURCE LINE # 940
0000 900000      R     MOV     DPTR,#ADC_CountsPerVolt
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 941
0006 22                RET     
             ; FUNCTION _ADC_SetGain (END)

             ; FUNCTION _ADC_CountsTo_mVolts (BEGIN)
                                           ; SOURCE LINE # 965
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 966
                                           ; SOURCE LINE # 997
0006 900000      R     MOV     DPTR,#adcCounts
0009 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 52  

000A FC                MOV     R4,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D FD                MOV     R5,A
000E A3                INC     DPTR
000F E0                MOVX    A,@DPTR
0010 FE                MOV     R6,A
0011 A3                INC     DPTR
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 900000      R     MOV     DPTR,#ADC_Offset
0017 E0                MOVX    A,@DPTR
0018 F8                MOV     R0,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B F9                MOV     R1,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FA                MOV     R2,A
001F A3                INC     DPTR
0020 E0                MOVX    A,@DPTR
0021 FB                MOV     R3,A
0022 C3                CLR     C
0023 EF                MOV     A,R7
0024 9B                SUBB    A,R3
0025 FF                MOV     R7,A
0026 EE                MOV     A,R6
0027 9A                SUBB    A,R2
0028 FE                MOV     R6,A
0029 ED                MOV     A,R5
002A 99                SUBB    A,R1
002B FD                MOV     R5,A
002C EC                MOV     A,R4
002D 98                SUBB    A,R0
002E FC                MOV     R4,A
002F 900000      R     MOV     DPTR,#adcCounts
0032 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 999
0035 E4                CLR     A
0036 7FE8              MOV     R7,#0E8H
0038 7E03              MOV     R6,#03H
003A FD                MOV     R5,A
003B FC                MOV     R4,A
003C 900000      R     MOV     DPTR,#adcCounts
003F E0                MOVX    A,@DPTR
0040 F8                MOV     R0,A
0041 A3                INC     DPTR
0042 E0                MOVX    A,@DPTR
0043 F9                MOV     R1,A
0044 A3                INC     DPTR
0045 E0                MOVX    A,@DPTR
0046 FA                MOV     R2,A
0047 A3                INC     DPTR
0048 E0                MOVX    A,@DPTR
0049 FB                MOV     R3,A
004A 120000      E     LCALL   ?C?LMUL
004D 900000      R     MOV     DPTR,#ADC_CountsPerVolt
0050 E0                MOVX    A,@DPTR
0051 F8                MOV     R0,A
0052 A3                INC     DPTR
0053 E0                MOVX    A,@DPTR
0054 F9                MOV     R1,A
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 53  

0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 FA                MOV     R2,A
0058 A3                INC     DPTR
0059 E0                MOVX    A,@DPTR
005A FB                MOV     R3,A
005B 120000      E     LCALL   ?C?SLDIV
;---- Variable 'mVolts' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 1001
                                           ; SOURCE LINE # 1002
005E         ?C0046:
005E 22                RET     
             ; FUNCTION _ADC_CountsTo_mVolts (END)

             ; FUNCTION _ADC_CountsTo_Volts (BEGIN)
                                           ; SOURCE LINE # 1026
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1027
                                           ; SOURCE LINE # 1058
0006 900000      R     MOV     DPTR,#adcCounts
0009 E0                MOVX    A,@DPTR
000A FC                MOV     R4,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D FD                MOV     R5,A
000E A3                INC     DPTR
000F E0                MOVX    A,@DPTR
0010 FE                MOV     R6,A
0011 A3                INC     DPTR
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 900000      R     MOV     DPTR,#ADC_Offset
0017 E0                MOVX    A,@DPTR
0018 F8                MOV     R0,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B F9                MOV     R1,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FA                MOV     R2,A
001F A3                INC     DPTR
0020 E0                MOVX    A,@DPTR
0021 FB                MOV     R3,A
0022 C3                CLR     C
0023 EF                MOV     A,R7
0024 9B                SUBB    A,R3
0025 FF                MOV     R7,A
0026 EE                MOV     A,R6
0027 9A                SUBB    A,R2
0028 FE                MOV     R6,A
0029 ED                MOV     A,R5
002A 99                SUBB    A,R1
002B FD                MOV     R5,A
002C EC                MOV     A,R4
002D 98                SUBB    A,R0
002E FC                MOV     R4,A
002F 900000      R     MOV     DPTR,#adcCounts
0032 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1060
0035 900000      R     MOV     DPTR,#ADC_CountsPerVolt
0038 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 54  

0039 FC                MOV     R4,A
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C FD                MOV     R5,A
003D A3                INC     DPTR
003E E0                MOVX    A,@DPTR
003F FE                MOV     R6,A
0040 A3                INC     DPTR
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 EC                MOV     A,R4
0044 120000      E     LCALL   ?C?FCASTL
0047 C004              PUSH    AR4
0049 C005              PUSH    AR5
004B C006              PUSH    AR6
004D C007              PUSH    AR7
004F 900000      R     MOV     DPTR,#adcCounts
0052 E0                MOVX    A,@DPTR
0053 FC                MOV     R4,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FD                MOV     R5,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FE                MOV     R6,A
005A A3                INC     DPTR
005B E0                MOVX    A,@DPTR
005C FF                MOV     R7,A
005D EC                MOV     A,R4
005E 120000      E     LCALL   ?C?FCASTL
0061 D003              POP     AR3
0063 D002              POP     AR2
0065 D001              POP     AR1
0067 D000              POP     AR0
0069 120000      E     LCALL   ?C?FPDIV
;---- Variable 'Volts' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1062
                                           ; SOURCE LINE # 1063
006C         ?C0047:
006C 22                RET     
             ; FUNCTION _ADC_CountsTo_Volts (END)

             ; FUNCTION _ADC_CountsTo_uVolts (BEGIN)
                                           ; SOURCE LINE # 1092
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1093
                                           ; SOURCE LINE # 1102
0006 900000      R     MOV     DPTR,#ADC_Config
0009 E0                MOVX    A,@DPTR
000A B40108            CJNE    A,#01H,?C0048
                                           ; SOURCE LINE # 1103
                                           ; SOURCE LINE # 1104
000D 900000      R     MOV     DPTR,#resolution
0010 740C              MOV     A,#0CH
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1108
0013 8024              SJMP    ?C0049
0015         ?C0048:
                                           ; SOURCE LINE # 1109
0015 900000      R     MOV     DPTR,#ADC_Config
0018 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 55  

0019 B40208            CJNE    A,#02H,?C0050
                                           ; SOURCE LINE # 1110
                                           ; SOURCE LINE # 1111
001C 900000      R     MOV     DPTR,#resolution
001F 7410              MOV     A,#010H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1115
0022 8015              SJMP    ?C0049
0024         ?C0050:
                                           ; SOURCE LINE # 1116
0024 900000      R     MOV     DPTR,#ADC_Config
0027 E0                MOVX    A,@DPTR
0028 B40308            CJNE    A,#03H,?C0052
                                           ; SOURCE LINE # 1117
                                           ; SOURCE LINE # 1118
002B 900000      R     MOV     DPTR,#resolution
002E 7410              MOV     A,#010H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1122
0031 8006              SJMP    ?C0049
0033         ?C0052:
                                           ; SOURCE LINE # 1124
                                           ; SOURCE LINE # 1125
0033 900000      R     MOV     DPTR,#resolution
0036 7410              MOV     A,#010H
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1129
0039         ?C0049:
                                           ; SOURCE LINE # 1131
0039 900000      R     MOV     DPTR,#resolution
003C E0                MOVX    A,@DPTR
003D 24F0              ADD     A,#0F0H
003F 6020              JZ      ?C0056
0041 2404              ADD     A,#04H
0043 7037              JNZ     ?C0057
                                           ; SOURCE LINE # 1132
                                           ; SOURCE LINE # 1137
0045         ?C0055:
                                           ; SOURCE LINE # 1138
0045 7F20              MOV     R7,#020H
0047 7EA1              MOV     R6,#0A1H
0049 7D07              MOV     R5,#07H
004B 7C00              MOV     R4,#00H
004D 900000      R     MOV     DPTR,#coefA
0050 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1139
0053 E4                CLR     A
0054 7F02              MOV     R7,#02H
0056 FE                MOV     R6,A
0057 FD                MOV     R5,A
0058 FC                MOV     R4,A
0059 900000      R     MOV     DPTR,#coefB
005C 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1140
005F 8035              SJMP    ?C0054
                                           ; SOURCE LINE # 1173
0061         ?C0056:
                                           ; SOURCE LINE # 1174
0061 E4                CLR     A
0062 7F12              MOV     R7,#012H
0064 7E7A              MOV     R6,#07AH
0066 FD                MOV     R5,A
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 56  

0067 FC                MOV     R4,A
0068 900000      R     MOV     DPTR,#coefA
006B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1175
006E E4                CLR     A
006F 7F20              MOV     R7,#020H
0071 FE                MOV     R6,A
0072 FD                MOV     R5,A
0073 FC                MOV     R4,A
0074 900000      R     MOV     DPTR,#coefB
0077 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1176
007A 801A              SJMP    ?C0054
                                           ; SOURCE LINE # 1214
007C         ?C0057:
                                           ; SOURCE LINE # 1216
007C 7F40              MOV     R7,#040H
007E 7E42              MOV     R6,#042H
0080 7D0F              MOV     R5,#0FH
0082 7C00              MOV     R4,#00H
0084 900000      R     MOV     DPTR,#coefA
0087 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1217
008A E4                CLR     A
008B 7F01              MOV     R7,#01H
008D FE                MOV     R6,A
008E FD                MOV     R5,A
008F FC                MOV     R4,A
0090 900000      R     MOV     DPTR,#coefB
0093 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1218
                                           ; SOURCE LINE # 1219
0096         ?C0054:
                                           ; SOURCE LINE # 1220
0096 900000      R     MOV     DPTR,#coefB
0099 E0                MOVX    A,@DPTR
009A F8                MOV     R0,A
009B A3                INC     DPTR
009C E0                MOVX    A,@DPTR
009D F9                MOV     R1,A
009E A3                INC     DPTR
009F E0                MOVX    A,@DPTR
00A0 FA                MOV     R2,A
00A1 A3                INC     DPTR
00A2 E0                MOVX    A,@DPTR
00A3 FB                MOV     R3,A
00A4 900000      R     MOV     DPTR,#ADC_CountsPerVolt
00A7 E0                MOVX    A,@DPTR
00A8 FC                MOV     R4,A
00A9 A3                INC     DPTR
00AA E0                MOVX    A,@DPTR
00AB FD                MOV     R5,A
00AC A3                INC     DPTR
00AD E0                MOVX    A,@DPTR
00AE FE                MOV     R6,A
00AF A3                INC     DPTR
00B0 E0                MOVX    A,@DPTR
00B1 FF                MOV     R7,A
00B2 120000      E     LCALL   ?C?SLDIV
00B5 900000      R     MOV     DPTR,#coefB
00B8 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1221
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 57  

00BB 900000      R     MOV     DPTR,#ADC_Offset
00BE E0                MOVX    A,@DPTR
00BF FC                MOV     R4,A
00C0 A3                INC     DPTR
00C1 E0                MOVX    A,@DPTR
00C2 FD                MOV     R5,A
00C3 A3                INC     DPTR
00C4 E0                MOVX    A,@DPTR
00C5 FE                MOV     R6,A
00C6 A3                INC     DPTR
00C7 E0                MOVX    A,@DPTR
00C8 FF                MOV     R7,A
00C9 900000      R     MOV     DPTR,#coefA
00CC E0                MOVX    A,@DPTR
00CD F8                MOV     R0,A
00CE A3                INC     DPTR
00CF E0                MOVX    A,@DPTR
00D0 F9                MOV     R1,A
00D1 A3                INC     DPTR
00D2 E0                MOVX    A,@DPTR
00D3 FA                MOV     R2,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 FB                MOV     R3,A
00D7 120000      E     LCALL   ?C?LMUL
00DA 900000      R     MOV     DPTR,#coefB
00DD E0                MOVX    A,@DPTR
00DE F8                MOV     R0,A
00DF A3                INC     DPTR
00E0 E0                MOVX    A,@DPTR
00E1 F9                MOV     R1,A
00E2 A3                INC     DPTR
00E3 E0                MOVX    A,@DPTR
00E4 FA                MOV     R2,A
00E5 A3                INC     DPTR
00E6 E0                MOVX    A,@DPTR
00E7 FB                MOV     R3,A
00E8 120000      E     LCALL   ?C?SLDIV
00EB C004              PUSH    AR4
00ED C005              PUSH    AR5
00EF C006              PUSH    AR6
00F1 C007              PUSH    AR7
00F3 900000      R     MOV     DPTR,#adcCounts
00F6 E0                MOVX    A,@DPTR
00F7 FC                MOV     R4,A
00F8 A3                INC     DPTR
00F9 E0                MOVX    A,@DPTR
00FA FD                MOV     R5,A
00FB A3                INC     DPTR
00FC E0                MOVX    A,@DPTR
00FD FE                MOV     R6,A
00FE A3                INC     DPTR
00FF E0                MOVX    A,@DPTR
0100 FF                MOV     R7,A
0101 A3                INC     DPTR
0102 E0                MOVX    A,@DPTR
0103 F8                MOV     R0,A
0104 A3                INC     DPTR
0105 E0                MOVX    A,@DPTR
0106 F9                MOV     R1,A
0107 A3                INC     DPTR
0108 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 58  

0109 FA                MOV     R2,A
010A A3                INC     DPTR
010B E0                MOVX    A,@DPTR
010C FB                MOV     R3,A
010D 120000      E     LCALL   ?C?LMUL
0110 900000      R     MOV     DPTR,#coefB
0113 E0                MOVX    A,@DPTR
0114 F8                MOV     R0,A
0115 A3                INC     DPTR
0116 E0                MOVX    A,@DPTR
0117 F9                MOV     R1,A
0118 A3                INC     DPTR
0119 E0                MOVX    A,@DPTR
011A FA                MOV     R2,A
011B A3                INC     DPTR
011C E0                MOVX    A,@DPTR
011D FB                MOV     R3,A
011E 120000      E     LCALL   ?C?SLDIV
0121 D003              POP     AR3
0123 D002              POP     AR2
0125 D001              POP     AR1
0127 D000              POP     AR0
0129 C3                CLR     C
012A EF                MOV     A,R7
012B 9B                SUBB    A,R3
012C FF                MOV     R7,A
012D EE                MOV     A,R6
012E 9A                SUBB    A,R2
012F FE                MOV     R6,A
0130 ED                MOV     A,R5
0131 99                SUBB    A,R1
0132 FD                MOV     R5,A
0133 EC                MOV     A,R4
0134 98                SUBB    A,R0
0135 FC                MOV     R4,A
;---- Variable 'uVolts' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1223
                                           ; SOURCE LINE # 1224
0136         ?C0058:
0136 22                RET     
             ; FUNCTION _ADC_CountsTo_uVolts (END)

             ; FUNCTION _ADC_InitConfig (BEGIN)
                                           ; SOURCE LINE # 1247
;---- Variable 'config' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1248
                                           ; SOURCE LINE # 1249
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#ADC_stopConversion
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1251
0005 EF                MOV     A,R7
0006 6401              XRL     A,#01H
0008 6003              JZ      $ + 5H
000A 020000      R     LJMP    ?C0060
                                           ; SOURCE LINE # 1252
                                           ; SOURCE LINE # 1254
000D 904E00            MOV     DPTR,#04E00H
0010 7432              MOV     A,#032H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1255
0013 904E02            MOV     DPTR,#04E02H
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 59  

0016 7406              MOV     A,#06H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1256
0019 A3                INC     DPTR
001A 7408              MOV     A,#08H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1257
001D A3                INC     DPTR
001E E4                CLR     A
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1258
0020 A3                INC     DPTR
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1259
0022 A3                INC     DPTR
0023 741F              MOV     A,#01FH
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1260
0026 904E08            MOV     DPTR,#04E08H
0029 E4                CLR     A
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1261
002B A3                INC     DPTR
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1262
002D A3                INC     DPTR
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1263
002F 904E14            MOV     DPTR,#04E14H
0032 04                INC     A
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1265
0034 905884            MOV     DPTR,#05884H
0037 7414              MOV     A,#014H
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1266
003A A3                INC     DPTR
003B 7405              MOV     A,#05H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1267
003E A3                INC     DPTR
003F 7416              MOV     A,#016H
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1268
0042 A3                INC     DPTR
0043 E4                CLR     A
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1269
0045 90588A            MOV     DPTR,#0588AH
0048 7444              MOV     A,#044H
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1270
004B A3                INC     DPTR
004C 7448              MOV     A,#048H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1271
004F A3                INC     DPTR
0050 7401              MOV     A,#01H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1272
0053 90588E            MOV     DPTR,#0588EH
0056 04                INC     A
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 60  

0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1273
0058 A3                INC     DPTR
0059 7422              MOV     A,#022H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1274
005C A3                INC     DPTR
005D 7428              MOV     A,#028H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1275
0060 A3                INC     DPTR
0061 74EB              MOV     A,#0EBH
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1277
0064 7F52              MOV     R7,#052H
0066 120000      R     LCALL   _ADC_SetDSMRef0Reg
                                           ; SOURCE LINE # 1278
0069 905894            MOV     DPTR,#05894H
006C 7458              MOV     A,#058H
006E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1279
006F A3                INC     DPTR
0070 E4                CLR     A
0071 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1281
0072 90589A            MOV     DPTR,#0589AH
0075 04                INC     A
0076 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1282
0077 A3                INC     DPTR
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1283
0079 A3                INC     DPTR
007A E4                CLR     A
007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1284
007C A3                INC     DPTR
007D 740A              MOV     A,#0AH
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1293
0080 E4                CLR     A
0081 FF                MOV     R7,A
0082 120000      E     LCALL   _ADC_AMux_Select
                                           ; SOURCE LINE # 1305
0085 E4                CLR     A
0086 7F33              MOV     R7,#033H
0088 7E03              MOV     R6,#03H
008A FD                MOV     R5,A
008B FC                MOV     R4,A
008C 900000      R     MOV     DPTR,#ADC_CountsPerVolt
008F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1307
0092 7D01              MOV     R5,#01H
0094 7F04              MOV     R7,#04H
0096 7E00              MOV     R6,#00H
0098 120000      E     LCALL   _ADC_Ext_CP_Clk_SetDividerRegister
                                           ; SOURCE LINE # 1311
009B 7D01              MOV     R5,#01H
009D 7F15              MOV     R7,#015H
009F 7E00              MOV     R6,#00H
00A1 120000      E     LCALL   _ADC_theACLK_SetDividerRegister
                                           ; SOURCE LINE # 1316
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 61  

00A4 7C00        E     MOV     R4,#HIGH ADC_ISR1
00A6 7D00        E     MOV     R5,#LOW ADC_ISR1
00A8 7F1D              MOV     R7,#01DH
00AA 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 1318
                                           ; SOURCE LINE # 1531
00AD         ?C0060:
00AD 22                RET     
             ; FUNCTION _ADC_InitConfig (END)

             ; FUNCTION _ADC_SelectConfiguration (BEGIN)
                                           ; SOURCE LINE # 1560
0000 900000      R     MOV     DPTR,#restart
0003 ED                MOV     A,R5
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#config
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1562
                                           ; SOURCE LINE # 1564
000A D3                SETB    C
000B 9400              SUBB    A,#00H
000D 4062              JC      ?C0065
000F E0                MOVX    A,@DPTR
0010 FF                MOV     R7,A
0011 D3                SETB    C
0012 9401              SUBB    A,#01H
0014 505B              JNC     ?C0065
                                           ; SOURCE LINE # 1565
                                           ; SOURCE LINE # 1569
0016 900000      R     MOV     DPTR,#ADC_initVar
0019 E0                MOVX    A,@DPTR
001A 7005              JNZ     ?C0062
                                           ; SOURCE LINE # 1570
                                           ; SOURCE LINE # 1571
001C 900000      R     MOV     DPTR,#ADC_started
001F 04                INC     A
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1572
0021         ?C0062:
                                           ; SOURCE LINE # 1575
0021 900000      R     MOV     DPTR,#ADC_Config
0024 EF                MOV     A,R7
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1578
0026 120000      R     LCALL   ADC_Stop
                                           ; SOURCE LINE # 1581
0029 900000      R     MOV     DPTR,#config
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E 120000      R     LCALL   _ADC_InitConfig
                                           ; SOURCE LINE # 1584
0031 900000      R     MOV     DPTR,#config
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 75F003            MOV     B,#03H
0039 A4                MUL     AB
003A 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
003C F582              MOV     DPL,A
003E E4                CLR     A
003F 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
0041 F583              MOV     DPH,A
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 62  

0043 E0                MOVX    A,@DPTR
0044 904E0E            MOV     DPTR,#04E0EH
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1585
0048 EF                MOV     A,R7
0049 75F003            MOV     B,#03H
004C A4                MUL     AB
004D 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
004F F582              MOV     DPL,A
0051 E4                CLR     A
0052 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0054 F583              MOV     DPH,A
0056 E0                MOVX    A,@DPTR
0057 FC                MOV     R4,A
0058 A3                INC     DPTR
0059 E0                MOVX    A,@DPTR
005A FD                MOV     R5,A
005B 7B02              MOV     R3,#02H
005D 7A4E              MOV     R2,#04EH
005F 790C              MOV     R1,#0CH
0061 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 1587
0064 900000      R     MOV     DPTR,#restart
0067 E0                MOVX    A,@DPTR
0068 B40106            CJNE    A,#01H,?C0065
                                           ; SOURCE LINE # 1588
                                           ; SOURCE LINE # 1590
006B 120000      R     LCALL   ADC_Start
                                           ; SOURCE LINE # 1593
006E 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1594
                                           ; SOURCE LINE # 1595
                                           ; SOURCE LINE # 1597
                                           ; SOURCE LINE # 1600
                                           ; SOURCE LINE # 1601
0071         ?C0065:
0071 22                RET     
             ; FUNCTION _ADC_SelectConfiguration (END)

             ; FUNCTION _ADC_GainCompensation (BEGIN)
                                           ; SOURCE LINE # 1625
0000 900000      R     MOV     DPTR,#idealDecGain
0003 EC                MOV     A,R4
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EA                MOV     A,R2
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C EB                MOV     A,R3
000D F0                MOVX    @DPTR,A
;---- Variable 'inputRange' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1627
                                           ; SOURCE LINE # 1633
000E 900000      R     MOV     DPTR,#config
0011 E0                MOVX    A,@DPTR
0012 FE                MOV     R6,A
0013 D3                SETB    C
0014 9400              SUBB    A,#00H
0016 5003              JNC     $ + 5H
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 63  

0018 020000      R     LJMP    ?C0085
001B EE                MOV     A,R6
001C D3                SETB    C
001D 9401              SUBB    A,#01H
001F 4003              JC      $ + 5H
0021 020000      R     LJMP    ?C0085
                                           ; SOURCE LINE # 1634
                                           ; SOURCE LINE # 1635
0024 EF                MOV     A,R7
0025 24FC              ADD     A,#0FCH
0027 6015              JZ      ?C0069
0029 24FD              ADD     A,#0FDH
002B 603C              JZ      ?C0072
002D 14                DEC     A
002E 6062              JZ      ?C0075
0030 24FE              ADD     A,#0FEH
0032 7003              JNZ     $ + 5H
0034 020000      R     LJMP    ?C0078
0037 2409              ADD     A,#09H
0039 6003              JZ      $ + 5H
003B 020000      R     LJMP    ?C0081
                                           ; SOURCE LINE # 1636
                                           ; SOURCE LINE # 1637
                                           ; SOURCE LINE # 1638
003E         ?C0069:
                                           ; SOURCE LINE # 1640
003E 900000      R     MOV     DPTR,#resolution
0041 E0                MOVX    A,@DPTR
0042 D3                SETB    C
0043 940F              SUBB    A,#0FH
0045 4011              JC      ?C0070
                                           ; SOURCE LINE # 1641
                                           ; SOURCE LINE # 1642
0047 7B0C              MOV     R3,#0CH
0049 7A01              MOV     R2,#01H
004B 7918              MOV     R1,#018H
004D 120000      E     LCALL   _cyread8
0050 900000      R     MOV     DPTR,#flash
0053 EF                MOV     A,R7
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1643
0055 020000      R     LJMP    ?C0067
0058         ?C0070:
                                           ; SOURCE LINE # 1645
                                           ; SOURCE LINE # 1646
0058 7B0C              MOV     R3,#0CH
005A 7A01              MOV     R2,#01H
005C 791C              MOV     R1,#01CH
005E 120000      E     LCALL   _cyread8
0061 900000      R     MOV     DPTR,#flash
0064 EF                MOV     A,R7
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1647
                                           ; SOURCE LINE # 1648
0066 020000      R     LJMP    ?C0067
                                           ; SOURCE LINE # 1650
0069         ?C0072:
                                           ; SOURCE LINE # 1652
0069 900000      R     MOV     DPTR,#resolution
006C E0                MOVX    A,@DPTR
006D D3                SETB    C
006E 940F              SUBB    A,#0FH
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 64  

0070 4010              JC      ?C0073
                                           ; SOURCE LINE # 1653
                                           ; SOURCE LINE # 1654
0072 7B0C              MOV     R3,#0CH
0074 7A01              MOV     R2,#01H
0076 7919              MOV     R1,#019H
0078 120000      E     LCALL   _cyread8
007B 900000      R     MOV     DPTR,#flash
007E EF                MOV     A,R7
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1655
0080 8067              SJMP    ?C0067
0082         ?C0073:
                                           ; SOURCE LINE # 1657
                                           ; SOURCE LINE # 1658
0082 7B0C              MOV     R3,#0CH
0084 7A01              MOV     R2,#01H
0086 791D              MOV     R1,#01DH
0088 120000      E     LCALL   _cyread8
008B 900000      R     MOV     DPTR,#flash
008E EF                MOV     A,R7
008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1659
                                           ; SOURCE LINE # 1660
0090 8057              SJMP    ?C0067
                                           ; SOURCE LINE # 1662
0092         ?C0075:
                                           ; SOURCE LINE # 1664
0092 900000      R     MOV     DPTR,#resolution
0095 E0                MOVX    A,@DPTR
0096 D3                SETB    C
0097 940F              SUBB    A,#0FH
0099 4010              JC      ?C0076
                                           ; SOURCE LINE # 1665
                                           ; SOURCE LINE # 1666
009B 7B0C              MOV     R3,#0CH
009D 7A01              MOV     R2,#01H
009F 791A              MOV     R1,#01AH
00A1 120000      E     LCALL   _cyread8
00A4 900000      R     MOV     DPTR,#flash
00A7 EF                MOV     A,R7
00A8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1667
00A9 803E              SJMP    ?C0067
00AB         ?C0076:
                                           ; SOURCE LINE # 1669
                                           ; SOURCE LINE # 1670
00AB 7B0C              MOV     R3,#0CH
00AD 7A01              MOV     R2,#01H
00AF 791E              MOV     R1,#01EH
00B1 120000      E     LCALL   _cyread8
00B4 900000      R     MOV     DPTR,#flash
00B7 EF                MOV     A,R7
00B8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1671
                                           ; SOURCE LINE # 1672
00B9 802E              SJMP    ?C0067
                                           ; SOURCE LINE # 1674
00BB         ?C0078:
                                           ; SOURCE LINE # 1676
00BB 900000      R     MOV     DPTR,#resolution
00BE E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 65  

00BF D3                SETB    C
00C0 940F              SUBB    A,#0FH
00C2 4010              JC      ?C0079
                                           ; SOURCE LINE # 1677
                                           ; SOURCE LINE # 1678
00C4 7B0C              MOV     R3,#0CH
00C6 7A01              MOV     R2,#01H
00C8 791B              MOV     R1,#01BH
00CA 120000      E     LCALL   _cyread8
00CD 900000      R     MOV     DPTR,#flash
00D0 EF                MOV     A,R7
00D1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1679
00D2 8015              SJMP    ?C0067
00D4         ?C0079:
                                           ; SOURCE LINE # 1681
                                           ; SOURCE LINE # 1682
00D4 7B0C              MOV     R3,#0CH
00D6 7A01              MOV     R2,#01H
00D8 791F              MOV     R1,#01FH
00DA 120000      E     LCALL   _cyread8
00DD 900000      R     MOV     DPTR,#flash
00E0 EF                MOV     A,R7
00E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1683
                                           ; SOURCE LINE # 1684
00E2 8005              SJMP    ?C0067
                                           ; SOURCE LINE # 1686
00E4         ?C0081:
                                           ; SOURCE LINE # 1687
00E4 E4                CLR     A
00E5 900000      R     MOV     DPTR,#flash
00E8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1688
                                           ; SOURCE LINE # 1689
00E9         ?C0067:
                                           ; SOURCE LINE # 1692
00E9 900000      R     MOV     DPTR,#flash
00EC E0                MOVX    A,@DPTR
00ED FF                MOV     R7,A
00EE 33                RLC     A
00EF 95E0              SUBB    A,ACC
00F1 FE                MOV     R6,A
00F2 FD                MOV     R5,A
00F3 FC                MOV     R4,A
00F4 E4                CLR     A
00F5 7B20              MOV     R3,#020H
00F7 FA                MOV     R2,A
00F8 F9                MOV     R1,A
00F9 F8                MOV     R0,A
00FA 120000      E     LCALL   ?C?LMUL
00FD A804              MOV     R0,AR4
00FF A905              MOV     R1,AR5
0101 AA06              MOV     R2,AR6
0103 AB07              MOV     R3,AR7
0105 900000      R     MOV     DPTR,#idealDecGain
0108 E0                MOVX    A,@DPTR
0109 FE                MOV     R6,A
010A A3                INC     DPTR
010B E0                MOVX    A,@DPTR
010C FF                MOV     R7,A
010D E4                CLR     A
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 66  

010E FC                MOV     R4,A
010F FD                MOV     R5,A
0110 EB                MOV     A,R3
0111 2F                ADD     A,R7
0112 FF                MOV     R7,A
0113 EA                MOV     A,R2
0114 3E                ADDC    A,R6
0115 FE                MOV     R6,A
0116 ED                MOV     A,R5
0117 39                ADDC    A,R1
0118 FD                MOV     R5,A
0119 EC                MOV     A,R4
011A 38                ADDC    A,R0
011B FC                MOV     R4,A
;---- Variable 'normalised' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1693
011C AB07              MOV     R3,AR7
011E AA06              MOV     R2,AR6
0120 A905              MOV     R1,AR5
0122 F8                MOV     R0,A
0123 A3                INC     DPTR
0124 E0                MOVX    A,@DPTR
0125 FE                MOV     R6,A
0126 A3                INC     DPTR
0127 E0                MOVX    A,@DPTR
0128 FF                MOV     R7,A
0129 E4                CLR     A
012A FC                MOV     R4,A
012B FD                MOV     R5,A
012C 120000      E     LCALL   ?C?LMUL
;---- Variable 'gcorTmp' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1694
012F E4                CLR     A
0130 FB                MOV     R3,A
0131 7A80              MOV     R2,#080H
0133 F9                MOV     R1,A
0134 F8                MOV     R0,A
0135 120000      E     LCALL   ?C?ULDIV
;---- Variable 'gcorValue' assigned to Register 'R4/R5' ----
0138 AD07              MOV     R5,AR7
013A AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 1696
013C 900000      R     MOV     DPTR,#resolution
013F E0                MOVX    A,@DPTR
0140 C3                CLR     C
0141 940E              SUBB    A,#0EH
0143 502F              JNC     ?C0082
                                           ; SOURCE LINE # 1697
                                           ; SOURCE LINE # 1698
0145 E0                MOVX    A,@DPTR
0146 FB                MOV     R3,A
0147 C3                CLR     C
0148 740E              MOV     A,#0EH
014A 9B                SUBB    A,R3
014B FF                MOV     R7,A
014C ED                MOV     A,R5
014D A807              MOV     R0,AR7
014F 08                INC     R0
0150 8005              SJMP    ?C0093
0152         ?C0092:
0152 CE                XCH     A,R6
0153 C3                CLR     C
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 67  

0154 13                RRC     A
0155 CE                XCH     A,R6
0156 13                RRC     A
0157         ?C0093:
0157 D8F9              DJNZ    R0,?C0092
0159 FD                MOV     R5,A
015A AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 1699
015C EB                MOV     A,R3
015D 04                INC     A
015E FF                MOV     R7,A
015F 900000      R     MOV     DPTR,#config
0162 E0                MOVX    A,@DPTR
0163 75F003            MOV     B,#03H
0166 A4                MUL     AB
0167 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
0169 F582              MOV     DPL,A
016B E4                CLR     A
016C 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
016E F583              MOV     DPH,A
0170 EF                MOV     A,R7
0171 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1700
0172 8014              SJMP    ?C0083
0174         ?C0082:
                                           ; SOURCE LINE # 1702
                                           ; SOURCE LINE # 1704
0174 900000      R     MOV     DPTR,#config
0177 E0                MOVX    A,@DPTR
0178 75F003            MOV     B,#03H
017B A4                MUL     AB
017C 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
017E F582              MOV     DPL,A
0180 E4                CLR     A
0181 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
0183 F583              MOV     DPH,A
0185 740F              MOV     A,#0FH
0187 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1705
0188         ?C0083:
                                           ; SOURCE LINE # 1708
0188 AF05              MOV     R7,AR5
018A 900000      R     MOV     DPTR,#config
018D E0                MOVX    A,@DPTR
018E 75F003            MOV     B,#03H
0191 A4                MUL     AB
0192 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
0194 F582              MOV     DPL,A
0196 E4                CLR     A
0197 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0199 F583              MOV     DPH,A
019B EC                MOV     A,R4
019C F0                MOVX    @DPTR,A
019D A3                INC     DPTR
019E EF                MOV     A,R7
019F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1709
                                           ; SOURCE LINE # 1711
                                           ; SOURCE LINE # 1714
                                           ; SOURCE LINE # 1715
01A0         ?C0085:
01A0 22                RET     
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 68  

             ; FUNCTION _ADC_GainCompensation (END)

             ; FUNCTION _ADC_SetDSMRef0Reg (BEGIN)
                                           ; SOURCE LINE # 1732
0000 900000      R     MOV     DPTR,#value
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1733
                                           ; SOURCE LINE # 1735
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1738
000D 9046F8            MOV     DPTR,#046F8H
0010 E0                MOVX    A,@DPTR
0011 4403              ORL     A,#03H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1739
0014 A3                INC     DPTR
0015 E0                MOVX    A,@DPTR
0016 4403              ORL     A,#03H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1740
0019 900000      R     MOV     DPTR,#value
001C E0                MOVX    A,@DPTR
001D 905892            MOV     DPTR,#05892H
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1743
0021 7F03              MOV     R7,#03H
0023 7E00              MOV     R6,#00H
0025 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1745
0028 9046F8            MOV     DPTR,#046F8H
002B E0                MOVX    A,@DPTR
002C 54FC              ANL     A,#0FCH
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1746
002F A3                INC     DPTR
0030 E0                MOVX    A,@DPTR
0031 54FC              ANL     A,#0FCH
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1748
0034 900000      R     MOV     DPTR,#enableInterrupts
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1749
003C 22                RET     
             ; FUNCTION _ADC_SetDSMRef0Reg (END)

             ; FUNCTION ADC_Read8 (BEGIN)
                                           ; SOURCE LINE # 1770
                                           ; SOURCE LINE # 1771
                                           ; SOURCE LINE # 1775
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1776
0007 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1777
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 69  

000A E4                CLR     A
000B FF                MOV     R7,A
000C 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1778
000F 120000      R     LCALL   ADC_GetResult8
;---- Variable 'result' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1779
0012 120000      R     LCALL   ADC_StopConvert
                                           ; SOURCE LINE # 1781
                                           ; SOURCE LINE # 1782
0015         ?C0087:
0015 22                RET     
             ; FUNCTION ADC_Read8 (END)

             ; FUNCTION ADC_Read16 (BEGIN)
                                           ; SOURCE LINE # 1803
                                           ; SOURCE LINE # 1804
                                           ; SOURCE LINE # 1808
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1809
0007 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1810
000A E4                CLR     A
000B FF                MOV     R7,A
000C 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1811
000F 120000      R     LCALL   ADC_GetResult16
;---- Variable 'result' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 1812
0012 120000      R     LCALL   ADC_StopConvert
                                           ; SOURCE LINE # 1814
                                           ; SOURCE LINE # 1815
0015         ?C0088:
0015 22                RET     
             ; FUNCTION ADC_Read16 (END)

             ; FUNCTION ADC_Read32 (BEGIN)
                                           ; SOURCE LINE # 1836
                                           ; SOURCE LINE # 1837
                                           ; SOURCE LINE # 1841
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1842
0007 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1843
000A E4                CLR     A
000B FF                MOV     R7,A
000C 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1844
000F 120000      R     LCALL   ADC_GetResult32
;---- Variable 'result' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1845
0012 120000      R     LCALL   ADC_StopConvert
                                           ; SOURCE LINE # 1847
                                           ; SOURCE LINE # 1848
0015         ?C0089:
0015 22                RET     
C51 COMPILER V9.51   ADC                                                                   02/09/2021 12:48:50 PAGE 70  

             ; FUNCTION ADC_Read32 (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2789    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
